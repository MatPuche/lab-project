{"version":3,"sources":["webpack:///../src/ol/format/GML3.js","webpack:///../src/ol/format/filter/Filter.js","webpack:///../src/ol/format/filter/LogicalNary.js","webpack:///../src/ol/format/filter/And.js","webpack:///../src/ol/format/filter/Bbox.js","webpack:///../src/ol/format/filter/Comparison.js","webpack:///../src/ol/format/filter/ComparisonBinary.js","webpack:///../src/ol/format/filter/EqualTo.js","webpack:///../src/ol/format/filter/IsLike.js","webpack:///../src/ol/format/filter.js","webpack:///../src/ol/format/WFS.js","webpack:///./vector-wfs-getfeature.js"],"names":["MULTIGEOMETRY_TO_MEMBER_NODENAME","opt_options","const","options","super","this","surface_","undefined","surface","curve_","curve","multiCurve_","multiCurve","multiSurface_","multiSurface","schemaLocation","hasZ","readMultiCurve","node","objectStack","lineStrings","MULTICURVE_PARSERS","MultiLineString","readMultiSurface","polygons","MULTISURFACE_PARSERS","MultiPolygon","curveMemberParser","CURVEMEMBER_PARSERS","surfaceMemberParser","SURFACEMEMBER_PARSERS","readPatch","PATCHES_PARSERS","readSegment","SEGMENTS_PARSERS","readPolygonPatch","FLAT_LINEAR_RINGS_PARSERS","readLineStringSegment","GEOMETRY_FLAT_COORDINATES_PARSERS","interiorParser","flatLinearRing","RING_PARSERS","length","push","exteriorParser","readSurface","flatLinearRings","SURFACE_PARSERS","i","ii","flatCoordinates","ends","Polygon","GeometryLayout","XYZ","readCurve","CURVE_PARSERS","LineString","readEnvelope","ENVELOPE_PARSERS","readFlatPos","let","m","s","re","exec","parseFloat","substr","containerSrs","axisOrientation","getAxisOrientation","y","x","len","readFlatPosList","replace","context","contextDimension","z","coords","split","dim","getAttribute","writePos_","value","srsDimension","setAttribute","srsName","point","getCoordinates","getCoords_","opt_srsName","opt_hasZ","writePosList_","points","parts","Array","join","writePoint","geometry","pos","namespaceURI","appendChild","writeEnvelope","extent","values","ENVELOPE_SERIALIZERS","writeLinearRing","posList","RING_NODE_FACTORY_","opt_nodeName","parentNode","exteriorWritten","writeSurfaceOrPolygon","nodeName","rings","getLinearRings","RING_SERIALIZERS","patches","writeSurfacePatches_","writeCurveOrLineString","segments","writeCurveSegments_","writeMultiSurfaceOrPolygon","getPolygons","SURFACEORPOLYGONMEMBER_SERIALIZERS","MULTIGEOMETRY_MEMBER_NODE_FACTORY_","writeMultiPoint","getPoints","POINTMEMBER_SERIALIZERS","writeMultiCurveOrLineString","lines","getLineStrings","LINESTRINGORCURVEMEMBER_SERIALIZERS","writeRing","ring","linearRing","writeSurfaceOrPolygonMember","polygon","child","GEOMETRY_NODE_FACTORY_","writePointMember","writeLineStringOrCurveMember","line","writeGeometryElement","item","isArray","GEOMETRY_SERIALIZERS","writeFeatureElement","feature","fid","getId","featureNS","geometryName","getGeometryName","serializers","keys","hasProperties","properties","getProperties","key","writeFeatureMembers_","features","featureType","namespace","getType","writeGeometryNode","adaptOptions","geom","writeFeaturesNode","setAttributeNS","prototype","GEOMETRY_PARSERS","readPoint","readMultiPoint","readLineString","readMultiLineString","readLinearRing","readPolygon","readMultiPolygon","writeFeatures","tagName","tagName_","getTagName","conditions","slice","call","arguments","Error","propertyName","expression","opt_matchCase","matchCase","pattern","opt_wildCard","opt_singleChar","opt_escapeChar","wildCard","singleChar","escapeChar","and","params","concat","Function","bind","apply","FEATURE_COLLECTION_PARSERS","readGeometryElement","TRANSACTION_SUMMARY_PARSERS","TRANSACTION_RESPONSE_PARSERS","INSERT_RESULTS_PARSERS","QUERY_SERIALIZERS","TRANSACTION_SERIALIZERS","gmlVersion","GML2","featurePrefix","typeName","getTypeName","XMLNS","getKeys","get","name","writeOgcFidFilter","pair","WFSNS","nativeElement","vendorId","safeToIgnore","String","OGCNS","SCHEMA_LOCATIONS","featureType_","featureNS_","gmlFormat_","gmlFormat","schemaLocation_","getFeatureType","setFeatureType","readFeaturesFromNode","getReadOptions","readFeaturesInternal","readTransactionResponse","source","doc","readTransactionResponseFromDocument","readTransactionResponseFromNode","readFeatureCollectionMetadata","readFeatureCollectionMetadataFromDocument","readFeatureCollectionMetadataFromNode","n","nextSibling","nodeType","Node","ELEMENT_NODE","result","writeGetFeature","filter","handle","outputFormat","maxFeatures","resultType","startIndex","count","viewParams","bbox","propertyNames","featureTypes","GETFEATURE_SERIALIZERS","writeTransaction","inserts","updates","deletes","baseObj","obj","version","gmlOptions","nativeElements","readProjectionFromDocument","firstChild","readProjectionFromNode","firstElementChild","nextElementSibling","childNodes","pop","OGC_FID_PARSERS","prefix","indexOf","writeFilterCondition","valueReference","timePeriod","begin","writeTimeInstant","end","writeLogicalFilter","condition","writeOgcPropertyName","writeComparisonFilter","lowerBoundary","writeOgcLiteral","upperBoundary","toString","writeOgcExpression","property","time","timeInstant","timePosition","vectorSource","Vector","vector","style","Style","stroke","Stroke","color","width","raster","Tile","attributions","url","maxZoom","map","Map","layers","target","document","getElementById","view","View","center","zoom","featureRequest","equalTo","fetch","method","body","XMLSerializer","serializeToString","then","response","json","GeoJSON","readFeatures","addFeatures","getView","fit","getExtent"],"mappings":"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","file":"vector-wfs-getfeature.js","sourcesContent":["/**\n * @module ol/format/GML3\n */\nimport GMLBase, {GMLNS} from './GMLBase.js';\nimport GeometryLayout from '../geom/GeometryLayout.js';\nimport LineString from '../geom/LineString.js';\nimport MultiLineString from '../geom/MultiLineString.js';\nimport MultiPolygon from '../geom/MultiPolygon.js';\nimport Polygon from '../geom/Polygon.js';\nimport {\n  OBJECT_PROPERTY_NODE_FACTORY,\n  XML_SCHEMA_INSTANCE_URI,\n  createElementNS,\n  getAllTextContent,\n  makeArrayPusher,\n  makeChildAppender,\n  makeReplacer,\n  makeSimpleNodeFactory,\n  parseNode,\n  pushParseAndPop,\n  pushSerializeAndPop,\n} from '../xml.js';\nimport {assign} from '../obj.js';\nimport {createOrUpdate} from '../extent.js';\nimport {extend} from '../array.js';\nimport {get as getProjection} from '../proj.js';\nimport {readNonNegativeIntegerString, writeStringTextNode} from './xsd.js';\nimport {\n  transformExtentWithOptions,\n  transformGeometryWithOptions,\n} from './Feature.js';\n\n/**\n * @const\n * @type {string}\n * @private\n */\nconst schemaLocation =\n  GMLNS +\n  ' http://schemas.opengis.net/gml/3.1.1/profiles/gmlsfProfile/' +\n  '1.0.0/gmlsf.xsd';\n\n/**\n * @const\n * @type {Object<string, string>}\n */\nconst MULTIGEOMETRY_TO_MEMBER_NODENAME = {\n  'MultiLineString': 'lineStringMember',\n  'MultiCurve': 'curveMember',\n  'MultiPolygon': 'polygonMember',\n  'MultiSurface': 'surfaceMember',\n};\n\n/**\n * @classdesc\n * Feature format for reading and writing data in the GML format\n * version 3.1.1.\n * Currently only supports GML 3.1.1 Simple Features profile.\n *\n * @api\n */\nclass GML3 extends GMLBase {\n  /**\n   * @param {import(\"./GMLBase.js\").Options=} opt_options Optional configuration object.\n   */\n  constructor(opt_options) {\n    const options =\n      /** @type {import(\"./GMLBase.js\").Options} */\n      (opt_options ? opt_options : {});\n\n    super(options);\n\n    /**\n     * @private\n     * @type {boolean}\n     */\n    this.surface_ = options.surface !== undefined ? options.surface : false;\n\n    /**\n     * @private\n     * @type {boolean}\n     */\n    this.curve_ = options.curve !== undefined ? options.curve : false;\n\n    /**\n     * @private\n     * @type {boolean}\n     */\n    this.multiCurve_ =\n      options.multiCurve !== undefined ? options.multiCurve : true;\n\n    /**\n     * @private\n     * @type {boolean}\n     */\n    this.multiSurface_ =\n      options.multiSurface !== undefined ? options.multiSurface : true;\n\n    /**\n     * @type {string}\n     */\n    this.schemaLocation = options.schemaLocation\n      ? options.schemaLocation\n      : schemaLocation;\n\n    /**\n     * @private\n     * @type {boolean}\n     */\n    this.hasZ = options.hasZ !== undefined ? options.hasZ : false;\n  }\n\n  /**\n   * @param {Element} node Node.\n   * @param {Array<*>} objectStack Object stack.\n   * @return {MultiLineString|undefined} MultiLineString.\n   */\n  readMultiCurve(node, objectStack) {\n    /** @type {Array<LineString>} */\n    const lineStrings = pushParseAndPop(\n      [],\n      this.MULTICURVE_PARSERS,\n      node,\n      objectStack,\n      this\n    );\n    if (lineStrings) {\n      const multiLineString = new MultiLineString(lineStrings);\n      return multiLineString;\n    } else {\n      return undefined;\n    }\n  }\n\n  /**\n   * @param {Element} node Node.\n   * @param {Array<*>} objectStack Object stack.\n   * @return {MultiPolygon|undefined} MultiPolygon.\n   */\n  readMultiSurface(node, objectStack) {\n    /** @type {Array<Polygon>} */\n    const polygons = pushParseAndPop(\n      [],\n      this.MULTISURFACE_PARSERS,\n      node,\n      objectStack,\n      this\n    );\n    if (polygons) {\n      return new MultiPolygon(polygons);\n    }\n  }\n\n  /**\n   * @param {Element} node Node.\n   * @param {Array<*>} objectStack Object stack.\n   */\n  curveMemberParser(node, objectStack) {\n    parseNode(this.CURVEMEMBER_PARSERS, node, objectStack, this);\n  }\n\n  /**\n   * @param {Element} node Node.\n   * @param {Array<*>} objectStack Object stack.\n   */\n  surfaceMemberParser(node, objectStack) {\n    parseNode(this.SURFACEMEMBER_PARSERS, node, objectStack, this);\n  }\n\n  /**\n   * @param {Element} node Node.\n   * @param {Array<*>} objectStack Object stack.\n   * @return {Array<(Array<number>)>|undefined} flat coordinates.\n   */\n  readPatch(node, objectStack) {\n    return pushParseAndPop(\n      [null],\n      this.PATCHES_PARSERS,\n      node,\n      objectStack,\n      this\n    );\n  }\n\n  /**\n   * @param {Element} node Node.\n   * @param {Array<*>} objectStack Object stack.\n   * @return {Array<number>|undefined} flat coordinates.\n   */\n  readSegment(node, objectStack) {\n    return pushParseAndPop(\n      [null],\n      this.SEGMENTS_PARSERS,\n      node,\n      objectStack,\n      this\n    );\n  }\n\n  /**\n   * @param {Element} node Node.\n   * @param {Array<*>} objectStack Object stack.\n   * @return {Array<(Array<number>)>|undefined} flat coordinates.\n   */\n  readPolygonPatch(node, objectStack) {\n    return pushParseAndPop(\n      [null],\n      this.FLAT_LINEAR_RINGS_PARSERS,\n      node,\n      objectStack,\n      this\n    );\n  }\n\n  /**\n   * @param {Element} node Node.\n   * @param {Array<*>} objectStack Object stack.\n   * @return {Array<number>|undefined} flat coordinates.\n   */\n  readLineStringSegment(node, objectStack) {\n    return pushParseAndPop(\n      [null],\n      this.GEOMETRY_FLAT_COORDINATES_PARSERS,\n      node,\n      objectStack,\n      this\n    );\n  }\n\n  /**\n   * @param {Element} node Node.\n   * @param {Array<*>} objectStack Object stack.\n   */\n  interiorParser(node, objectStack) {\n    /** @type {Array<number>|undefined} */\n    const flatLinearRing = pushParseAndPop(\n      undefined,\n      this.RING_PARSERS,\n      node,\n      objectStack,\n      this\n    );\n    if (flatLinearRing) {\n      const flatLinearRings =\n        /** @type {Array<Array<number>>} */\n        (objectStack[objectStack.length - 1]);\n      flatLinearRings.push(flatLinearRing);\n    }\n  }\n\n  /**\n   * @param {Element} node Node.\n   * @param {Array<*>} objectStack Object stack.\n   */\n  exteriorParser(node, objectStack) {\n    /** @type {Array<number>|undefined} */\n    const flatLinearRing = pushParseAndPop(\n      undefined,\n      this.RING_PARSERS,\n      node,\n      objectStack,\n      this\n    );\n    if (flatLinearRing) {\n      const flatLinearRings =\n        /** @type {Array<Array<number>>} */\n        (objectStack[objectStack.length - 1]);\n      flatLinearRings[0] = flatLinearRing;\n    }\n  }\n\n  /**\n   * @param {Element} node Node.\n   * @param {Array<*>} objectStack Object stack.\n   * @return {Polygon|undefined} Polygon.\n   */\n  readSurface(node, objectStack) {\n    /** @type {Array<Array<number>>} */\n    const flatLinearRings = pushParseAndPop(\n      [null],\n      this.SURFACE_PARSERS,\n      node,\n      objectStack,\n      this\n    );\n    if (flatLinearRings && flatLinearRings[0]) {\n      const flatCoordinates = flatLinearRings[0];\n      const ends = [flatCoordinates.length];\n      let i, ii;\n      for (i = 1, ii = flatLinearRings.length; i < ii; ++i) {\n        extend(flatCoordinates, flatLinearRings[i]);\n        ends.push(flatCoordinates.length);\n      }\n      return new Polygon(flatCoordinates, GeometryLayout.XYZ, ends);\n    } else {\n      return undefined;\n    }\n  }\n\n  /**\n   * @param {Element} node Node.\n   * @param {Array<*>} objectStack Object stack.\n   * @return {LineString|undefined} LineString.\n   */\n  readCurve(node, objectStack) {\n    /** @type {Array<number>} */\n    const flatCoordinates = pushParseAndPop(\n      [null],\n      this.CURVE_PARSERS,\n      node,\n      objectStack,\n      this\n    );\n    if (flatCoordinates) {\n      const lineString = new LineString(flatCoordinates, GeometryLayout.XYZ);\n      return lineString;\n    } else {\n      return undefined;\n    }\n  }\n\n  /**\n   * @param {Element} node Node.\n   * @param {Array<*>} objectStack Object stack.\n   * @return {import(\"../extent.js\").Extent|undefined} Envelope.\n   */\n  readEnvelope(node, objectStack) {\n    /** @type {Array<number>} */\n    const flatCoordinates = pushParseAndPop(\n      [null],\n      this.ENVELOPE_PARSERS,\n      node,\n      objectStack,\n      this\n    );\n    return createOrUpdate(\n      flatCoordinates[1][0],\n      flatCoordinates[1][1],\n      flatCoordinates[2][0],\n      flatCoordinates[2][1]\n    );\n  }\n\n  /**\n   * @param {Node} node Node.\n   * @param {Array<*>} objectStack Object stack.\n   * @return {Array<number>|undefined} Flat coordinates.\n   */\n  readFlatPos(node, objectStack) {\n    let s = getAllTextContent(node, false);\n    const re = /^\\s*([+\\-]?\\d*\\.?\\d+(?:[eE][+\\-]?\\d+)?)\\s*/;\n    /** @type {Array<number>} */\n    const flatCoordinates = [];\n    let m;\n    while ((m = re.exec(s))) {\n      flatCoordinates.push(parseFloat(m[1]));\n      s = s.substr(m[0].length);\n    }\n    if (s !== '') {\n      return undefined;\n    }\n    const context = objectStack[0];\n    const containerSrs = context['srsName'];\n    let axisOrientation = 'enu';\n    if (containerSrs) {\n      const proj = getProjection(containerSrs);\n      axisOrientation = proj.getAxisOrientation();\n    }\n    if (axisOrientation === 'neu') {\n      let i, ii;\n      for (i = 0, ii = flatCoordinates.length; i < ii; i += 3) {\n        const y = flatCoordinates[i];\n        const x = flatCoordinates[i + 1];\n        flatCoordinates[i] = x;\n        flatCoordinates[i + 1] = y;\n      }\n    }\n    const len = flatCoordinates.length;\n    if (len == 2) {\n      flatCoordinates.push(0);\n    }\n    if (len === 0) {\n      return undefined;\n    }\n    return flatCoordinates;\n  }\n\n  /**\n   * @param {Element} node Node.\n   * @param {Array<*>} objectStack Object stack.\n   * @return {Array<number>|undefined} Flat coordinates.\n   */\n  readFlatPosList(node, objectStack) {\n    const s = getAllTextContent(node, false).replace(/^\\s*|\\s*$/g, '');\n    const context = objectStack[0];\n    const containerSrs = context['srsName'];\n    const contextDimension = context['srsDimension'];\n    let axisOrientation = 'enu';\n    if (containerSrs) {\n      const proj = getProjection(containerSrs);\n      axisOrientation = proj.getAxisOrientation();\n    }\n    const coords = s.split(/\\s+/);\n    // The \"dimension\" attribute is from the GML 3.0.1 spec.\n    let dim = 2;\n    if (node.getAttribute('srsDimension')) {\n      dim = readNonNegativeIntegerString(node.getAttribute('srsDimension'));\n    } else if (node.getAttribute('dimension')) {\n      dim = readNonNegativeIntegerString(node.getAttribute('dimension'));\n    } else if (\n      /** @type {Element} */ (node.parentNode).getAttribute('srsDimension')\n    ) {\n      dim = readNonNegativeIntegerString(\n        /** @type {Element} */ (node.parentNode).getAttribute('srsDimension')\n      );\n    } else if (contextDimension) {\n      dim = readNonNegativeIntegerString(contextDimension);\n    }\n    let x, y, z;\n    const flatCoordinates = [];\n    for (let i = 0, ii = coords.length; i < ii; i += dim) {\n      x = parseFloat(coords[i]);\n      y = parseFloat(coords[i + 1]);\n      z = dim === 3 ? parseFloat(coords[i + 2]) : 0;\n      if (axisOrientation.substr(0, 2) === 'en') {\n        flatCoordinates.push(x, y, z);\n      } else {\n        flatCoordinates.push(y, x, z);\n      }\n    }\n    return flatCoordinates;\n  }\n\n  /**\n   * @param {Element} node Node.\n   * @param {import(\"../geom/Point.js\").default} value Point geometry.\n   * @param {Array<*>} objectStack Node stack.\n   * @private\n   */\n  writePos_(node, value, objectStack) {\n    const context = objectStack[objectStack.length - 1];\n    const hasZ = context['hasZ'];\n    const srsDimension = hasZ ? '3' : '2';\n    node.setAttribute('srsDimension', srsDimension);\n    const srsName = context['srsName'];\n    let axisOrientation = 'enu';\n    if (srsName) {\n      axisOrientation = getProjection(srsName).getAxisOrientation();\n    }\n    const point = value.getCoordinates();\n    let coords;\n    // only 2d for simple features profile\n    if (axisOrientation.substr(0, 2) === 'en') {\n      coords = point[0] + ' ' + point[1];\n    } else {\n      coords = point[1] + ' ' + point[0];\n    }\n    if (hasZ) {\n      // For newly created points, Z can be undefined.\n      const z = point[2] || 0;\n      coords += ' ' + z;\n    }\n    writeStringTextNode(node, coords);\n  }\n\n  /**\n   * @param {Array<number>} point Point geometry.\n   * @param {string=} opt_srsName Optional srsName\n   * @param {boolean=} opt_hasZ whether the geometry has a Z coordinate (is 3D) or not.\n   * @return {string} The coords string.\n   * @private\n   */\n  getCoords_(point, opt_srsName, opt_hasZ) {\n    let axisOrientation = 'enu';\n    if (opt_srsName) {\n      axisOrientation = getProjection(opt_srsName).getAxisOrientation();\n    }\n    let coords =\n      axisOrientation.substr(0, 2) === 'en'\n        ? point[0] + ' ' + point[1]\n        : point[1] + ' ' + point[0];\n    if (opt_hasZ) {\n      // For newly created points, Z can be undefined.\n      const z = point[2] || 0;\n      coords += ' ' + z;\n    }\n\n    return coords;\n  }\n\n  /**\n   * @param {Element} node Node.\n   * @param {LineString|import(\"../geom/LinearRing.js\").default} value Geometry.\n   * @param {Array<*>} objectStack Node stack.\n   * @private\n   */\n  writePosList_(node, value, objectStack) {\n    const context = objectStack[objectStack.length - 1];\n    const hasZ = context['hasZ'];\n    const srsDimension = hasZ ? '3' : '2';\n    node.setAttribute('srsDimension', srsDimension);\n    const srsName = context['srsName'];\n    // only 2d for simple features profile\n    const points = value.getCoordinates();\n    const len = points.length;\n    const parts = new Array(len);\n    let point;\n    for (let i = 0; i < len; ++i) {\n      point = points[i];\n      parts[i] = this.getCoords_(point, srsName, hasZ);\n    }\n    writeStringTextNode(node, parts.join(' '));\n  }\n\n  /**\n   * @param {Element} node Node.\n   * @param {import(\"../geom/Point.js\").default} geometry Point geometry.\n   * @param {Array<*>} objectStack Node stack.\n   */\n  writePoint(node, geometry, objectStack) {\n    const context = objectStack[objectStack.length - 1];\n    const srsName = context['srsName'];\n    if (srsName) {\n      node.setAttribute('srsName', srsName);\n    }\n    const pos = createElementNS(node.namespaceURI, 'pos');\n    node.appendChild(pos);\n    this.writePos_(pos, geometry, objectStack);\n  }\n\n  /**\n   * @param {Element} node Node.\n   * @param {import(\"../extent.js\").Extent} extent Extent.\n   * @param {Array<*>} objectStack Node stack.\n   */\n  writeEnvelope(node, extent, objectStack) {\n    const context = objectStack[objectStack.length - 1];\n    const srsName = context['srsName'];\n    if (srsName) {\n      node.setAttribute('srsName', srsName);\n    }\n    const keys = ['lowerCorner', 'upperCorner'];\n    const values = [extent[0] + ' ' + extent[1], extent[2] + ' ' + extent[3]];\n    pushSerializeAndPop(\n      /** @type {import(\"../xml.js\").NodeStackItem} */\n      ({node: node}),\n      this.ENVELOPE_SERIALIZERS,\n      OBJECT_PROPERTY_NODE_FACTORY,\n      values,\n      objectStack,\n      keys,\n      this\n    );\n  }\n\n  /**\n   * @param {Element} node Node.\n   * @param {import(\"../geom/LinearRing.js\").default} geometry LinearRing geometry.\n   * @param {Array<*>} objectStack Node stack.\n   */\n  writeLinearRing(node, geometry, objectStack) {\n    const context = objectStack[objectStack.length - 1];\n    const srsName = context['srsName'];\n    if (srsName) {\n      node.setAttribute('srsName', srsName);\n    }\n    const posList = createElementNS(node.namespaceURI, 'posList');\n    node.appendChild(posList);\n    this.writePosList_(posList, geometry, objectStack);\n  }\n\n  /**\n   * @param {*} value Value.\n   * @param {Array<*>} objectStack Object stack.\n   * @param {string=} opt_nodeName Node name.\n   * @return {Node} Node.\n   * @private\n   */\n  RING_NODE_FACTORY_(value, objectStack, opt_nodeName) {\n    const context = objectStack[objectStack.length - 1];\n    const parentNode = context.node;\n    const exteriorWritten = context['exteriorWritten'];\n    if (exteriorWritten === undefined) {\n      context['exteriorWritten'] = true;\n    }\n    return createElementNS(\n      parentNode.namespaceURI,\n      exteriorWritten !== undefined ? 'interior' : 'exterior'\n    );\n  }\n\n  /**\n   * @param {Element} node Node.\n   * @param {Polygon} geometry Polygon geometry.\n   * @param {Array<*>} objectStack Node stack.\n   */\n  writeSurfaceOrPolygon(node, geometry, objectStack) {\n    const context = objectStack[objectStack.length - 1];\n    const hasZ = context['hasZ'];\n    const srsName = context['srsName'];\n    if (node.nodeName !== 'PolygonPatch' && srsName) {\n      node.setAttribute('srsName', srsName);\n    }\n    if (node.nodeName === 'Polygon' || node.nodeName === 'PolygonPatch') {\n      const rings = geometry.getLinearRings();\n      pushSerializeAndPop(\n        {node: node, hasZ: hasZ, srsName: srsName},\n        this.RING_SERIALIZERS,\n        this.RING_NODE_FACTORY_,\n        rings,\n        objectStack,\n        undefined,\n        this\n      );\n    } else if (node.nodeName === 'Surface') {\n      const patches = createElementNS(node.namespaceURI, 'patches');\n      node.appendChild(patches);\n      this.writeSurfacePatches_(patches, geometry, objectStack);\n    }\n  }\n\n  /**\n   * @param {Element} node Node.\n   * @param {LineString} geometry LineString geometry.\n   * @param {Array<*>} objectStack Node stack.\n   */\n  writeCurveOrLineString(node, geometry, objectStack) {\n    const context = objectStack[objectStack.length - 1];\n    const srsName = context['srsName'];\n    if (node.nodeName !== 'LineStringSegment' && srsName) {\n      node.setAttribute('srsName', srsName);\n    }\n    if (\n      node.nodeName === 'LineString' ||\n      node.nodeName === 'LineStringSegment'\n    ) {\n      const posList = createElementNS(node.namespaceURI, 'posList');\n      node.appendChild(posList);\n      this.writePosList_(posList, geometry, objectStack);\n    } else if (node.nodeName === 'Curve') {\n      const segments = createElementNS(node.namespaceURI, 'segments');\n      node.appendChild(segments);\n      this.writeCurveSegments_(segments, geometry, objectStack);\n    }\n  }\n\n  /**\n   * @param {Element} node Node.\n   * @param {MultiPolygon} geometry MultiPolygon geometry.\n   * @param {Array<*>} objectStack Node stack.\n   */\n  writeMultiSurfaceOrPolygon(node, geometry, objectStack) {\n    const context = objectStack[objectStack.length - 1];\n    const hasZ = context['hasZ'];\n    const srsName = context['srsName'];\n    const surface = context['surface'];\n    if (srsName) {\n      node.setAttribute('srsName', srsName);\n    }\n    const polygons = geometry.getPolygons();\n    pushSerializeAndPop(\n      {node: node, hasZ: hasZ, srsName: srsName, surface: surface},\n      this.SURFACEORPOLYGONMEMBER_SERIALIZERS,\n      this.MULTIGEOMETRY_MEMBER_NODE_FACTORY_,\n      polygons,\n      objectStack,\n      undefined,\n      this\n    );\n  }\n\n  /**\n   * @param {Element} node Node.\n   * @param {import(\"../geom/MultiPoint.js\").default} geometry MultiPoint geometry.\n   * @param {Array<*>} objectStack Node stack.\n   */\n  writeMultiPoint(node, geometry, objectStack) {\n    const context = objectStack[objectStack.length - 1];\n    const srsName = context['srsName'];\n    const hasZ = context['hasZ'];\n    if (srsName) {\n      node.setAttribute('srsName', srsName);\n    }\n    const points = geometry.getPoints();\n    pushSerializeAndPop(\n      {node: node, hasZ: hasZ, srsName: srsName},\n      this.POINTMEMBER_SERIALIZERS,\n      makeSimpleNodeFactory('pointMember'),\n      points,\n      objectStack,\n      undefined,\n      this\n    );\n  }\n\n  /**\n   * @param {Element} node Node.\n   * @param {MultiLineString} geometry MultiLineString geometry.\n   * @param {Array<*>} objectStack Node stack.\n   */\n  writeMultiCurveOrLineString(node, geometry, objectStack) {\n    const context = objectStack[objectStack.length - 1];\n    const hasZ = context['hasZ'];\n    const srsName = context['srsName'];\n    const curve = context['curve'];\n    if (srsName) {\n      node.setAttribute('srsName', srsName);\n    }\n    const lines = geometry.getLineStrings();\n    pushSerializeAndPop(\n      {node: node, hasZ: hasZ, srsName: srsName, curve: curve},\n      this.LINESTRINGORCURVEMEMBER_SERIALIZERS,\n      this.MULTIGEOMETRY_MEMBER_NODE_FACTORY_,\n      lines,\n      objectStack,\n      undefined,\n      this\n    );\n  }\n\n  /**\n   * @param {Node} node Node.\n   * @param {import(\"../geom/LinearRing.js\").default} ring LinearRing geometry.\n   * @param {Array<*>} objectStack Node stack.\n   */\n  writeRing(node, ring, objectStack) {\n    const linearRing = createElementNS(node.namespaceURI, 'LinearRing');\n    node.appendChild(linearRing);\n    this.writeLinearRing(linearRing, ring, objectStack);\n  }\n\n  /**\n   * @param {Node} node Node.\n   * @param {Polygon} polygon Polygon geometry.\n   * @param {Array<*>} objectStack Node stack.\n   */\n  writeSurfaceOrPolygonMember(node, polygon, objectStack) {\n    const child = this.GEOMETRY_NODE_FACTORY_(polygon, objectStack);\n    if (child) {\n      node.appendChild(child);\n      this.writeSurfaceOrPolygon(child, polygon, objectStack);\n    }\n  }\n\n  /**\n   * @param {Node} node Node.\n   * @param {import(\"../geom/Point.js\").default} point Point geometry.\n   * @param {Array<*>} objectStack Node stack.\n   */\n  writePointMember(node, point, objectStack) {\n    const child = createElementNS(node.namespaceURI, 'Point');\n    node.appendChild(child);\n    this.writePoint(child, point, objectStack);\n  }\n\n  /**\n   * @param {Node} node Node.\n   * @param {LineString} line LineString geometry.\n   * @param {Array<*>} objectStack Node stack.\n   */\n  writeLineStringOrCurveMember(node, line, objectStack) {\n    const child = this.GEOMETRY_NODE_FACTORY_(line, objectStack);\n    if (child) {\n      node.appendChild(child);\n      this.writeCurveOrLineString(child, line, objectStack);\n    }\n  }\n\n  /**\n   * @param {Node} node Node.\n   * @param {Polygon} polygon Polygon geometry.\n   * @param {Array<*>} objectStack Node stack.\n   * @private\n   */\n  writeSurfacePatches_(node, polygon, objectStack) {\n    const child = createElementNS(node.namespaceURI, 'PolygonPatch');\n    node.appendChild(child);\n    this.writeSurfaceOrPolygon(child, polygon, objectStack);\n  }\n\n  /**\n   * @param {Node} node Node.\n   * @param {LineString} line LineString geometry.\n   * @param {Array<*>} objectStack Node stack.\n   * @private\n   */\n  writeCurveSegments_(node, line, objectStack) {\n    const child = createElementNS(node.namespaceURI, 'LineStringSegment');\n    node.appendChild(child);\n    this.writeCurveOrLineString(child, line, objectStack);\n  }\n\n  /**\n   * @param {Node} node Node.\n   * @param {import(\"../geom/Geometry.js\").default|import(\"../extent.js\").Extent} geometry Geometry.\n   * @param {Array<*>} objectStack Node stack.\n   */\n  writeGeometryElement(node, geometry, objectStack) {\n    const context = /** @type {import(\"./Feature.js\").WriteOptions} */ (objectStack[\n      objectStack.length - 1\n    ]);\n    const item = assign({}, context);\n    item['node'] = node;\n    let value;\n    if (Array.isArray(geometry)) {\n      value = transformExtentWithOptions(\n        /** @type {import(\"../extent.js\").Extent} */ (geometry),\n        context\n      );\n    } else {\n      value = transformGeometryWithOptions(\n        /** @type {import(\"../geom/Geometry.js\").default} */ (geometry),\n        true,\n        context\n      );\n    }\n    pushSerializeAndPop(\n      /** @type {import(\"../xml.js\").NodeStackItem} */\n      (item),\n      this.GEOMETRY_SERIALIZERS,\n      this.GEOMETRY_NODE_FACTORY_,\n      [value],\n      objectStack,\n      undefined,\n      this\n    );\n  }\n\n  /**\n   * @param {Element} node Node.\n   * @param {import(\"../Feature.js\").default} feature Feature.\n   * @param {Array<*>} objectStack Node stack.\n   */\n  writeFeatureElement(node, feature, objectStack) {\n    const fid = feature.getId();\n    if (fid) {\n      node.setAttribute('fid', /** @type {string} */ (fid));\n    }\n    const context = /** @type {Object} */ (objectStack[objectStack.length - 1]);\n    const featureNS = context['featureNS'];\n    const geometryName = feature.getGeometryName();\n    if (!context.serializers) {\n      context.serializers = {};\n      context.serializers[featureNS] = {};\n    }\n    const keys = [];\n    const values = [];\n    if (feature.hasProperties()) {\n      const properties = feature.getProperties();\n      for (const key in properties) {\n        const value = properties[key];\n        if (value !== null) {\n          keys.push(key);\n          values.push(value);\n          if (\n            key == geometryName ||\n            typeof (/** @type {?} */ (value).getSimplifiedGeometry) ===\n              'function'\n          ) {\n            if (!(key in context.serializers[featureNS])) {\n              context.serializers[featureNS][key] = makeChildAppender(\n                this.writeGeometryElement,\n                this\n              );\n            }\n          } else {\n            if (!(key in context.serializers[featureNS])) {\n              context.serializers[featureNS][key] = makeChildAppender(\n                writeStringTextNode\n              );\n            }\n          }\n        }\n      }\n    }\n    const item = assign({}, context);\n    item.node = node;\n    pushSerializeAndPop(\n      /** @type {import(\"../xml.js\").NodeStackItem} */\n      (item),\n      context.serializers,\n      makeSimpleNodeFactory(undefined, featureNS),\n      values,\n      objectStack,\n      keys\n    );\n  }\n\n  /**\n   * @param {Node} node Node.\n   * @param {Array<import(\"../Feature.js\").default>} features Features.\n   * @param {Array<*>} objectStack Node stack.\n   * @private\n   */\n  writeFeatureMembers_(node, features, objectStack) {\n    const context = /** @type {Object} */ (objectStack[objectStack.length - 1]);\n    const featureType = context['featureType'];\n    const featureNS = context['featureNS'];\n    /** @type {Object<string, Object<string, import(\"../xml.js\").Serializer>>} */\n    const serializers = {};\n    serializers[featureNS] = {};\n    serializers[featureNS][featureType] = makeChildAppender(\n      this.writeFeatureElement,\n      this\n    );\n    const item = assign({}, context);\n    item.node = node;\n    pushSerializeAndPop(\n      /** @type {import(\"../xml.js\").NodeStackItem} */\n      (item),\n      serializers,\n      makeSimpleNodeFactory(featureType, featureNS),\n      features,\n      objectStack\n    );\n  }\n\n  /**\n   * @const\n   * @param {*} value Value.\n   * @param {Array<*>} objectStack Object stack.\n   * @param {string=} opt_nodeName Node name.\n   * @return {Node|undefined} Node.\n   * @private\n   */\n  MULTIGEOMETRY_MEMBER_NODE_FACTORY_(value, objectStack, opt_nodeName) {\n    const parentNode = objectStack[objectStack.length - 1].node;\n    return createElementNS(\n      this.namespace,\n      MULTIGEOMETRY_TO_MEMBER_NODENAME[parentNode.nodeName]\n    );\n  }\n\n  /**\n   * @const\n   * @param {*} value Value.\n   * @param {Array<*>} objectStack Object stack.\n   * @param {string=} opt_nodeName Node name.\n   * @return {Element|undefined} Node.\n   * @private\n   */\n  GEOMETRY_NODE_FACTORY_(value, objectStack, opt_nodeName) {\n    const context = objectStack[objectStack.length - 1];\n    const multiSurface = context['multiSurface'];\n    const surface = context['surface'];\n    const curve = context['curve'];\n    const multiCurve = context['multiCurve'];\n    let nodeName;\n    if (!Array.isArray(value)) {\n      nodeName = /** @type {import(\"../geom/Geometry.js\").default} */ (value).getType();\n      if (nodeName === 'MultiPolygon' && multiSurface === true) {\n        nodeName = 'MultiSurface';\n      } else if (nodeName === 'Polygon' && surface === true) {\n        nodeName = 'Surface';\n      } else if (nodeName === 'LineString' && curve === true) {\n        nodeName = 'Curve';\n      } else if (nodeName === 'MultiLineString' && multiCurve === true) {\n        nodeName = 'MultiCurve';\n      }\n    } else {\n      nodeName = 'Envelope';\n    }\n    return createElementNS(this.namespace, nodeName);\n  }\n\n  /**\n   * Encode a geometry in GML 3.1.1 Simple Features.\n   *\n   * @param {import(\"../geom/Geometry.js\").default} geometry Geometry.\n   * @param {import(\"./Feature.js\").WriteOptions=} opt_options Options.\n   * @return {Node} Node.\n   * @api\n   */\n  writeGeometryNode(geometry, opt_options) {\n    opt_options = this.adaptOptions(opt_options);\n    const geom = createElementNS(this.namespace, 'geom');\n    const context = {\n      node: geom,\n      hasZ: this.hasZ,\n      srsName: this.srsName,\n      curve: this.curve_,\n      surface: this.surface_,\n      multiSurface: this.multiSurface_,\n      multiCurve: this.multiCurve_,\n    };\n    if (opt_options) {\n      assign(context, opt_options);\n    }\n    this.writeGeometryElement(geom, geometry, [context]);\n    return geom;\n  }\n\n  /**\n   * Encode an array of features in the GML 3.1.1 format as an XML node.\n   *\n   * @param {Array<import(\"../Feature.js\").default>} features Features.\n   * @param {import(\"./Feature.js\").WriteOptions=} opt_options Options.\n   * @return {Element} Node.\n   * @api\n   */\n  writeFeaturesNode(features, opt_options) {\n    opt_options = this.adaptOptions(opt_options);\n    const node = createElementNS(this.namespace, 'featureMembers');\n    node.setAttributeNS(\n      XML_SCHEMA_INSTANCE_URI,\n      'xsi:schemaLocation',\n      this.schemaLocation\n    );\n    const context = {\n      srsName: this.srsName,\n      hasZ: this.hasZ,\n      curve: this.curve_,\n      surface: this.surface_,\n      multiSurface: this.multiSurface_,\n      multiCurve: this.multiCurve_,\n      featureNS: this.featureNS,\n      featureType: this.featureType,\n    };\n    if (opt_options) {\n      assign(context, opt_options);\n    }\n    this.writeFeatureMembers_(node, features, [context]);\n    return node;\n  }\n}\n\n/**\n * @const\n * @type {Object<string, Object<string, import(\"../xml.js\").Parser>>}\n */\nGML3.prototype.GEOMETRY_FLAT_COORDINATES_PARSERS = {\n  'http://www.opengis.net/gml': {\n    'pos': makeReplacer(GML3.prototype.readFlatPos),\n    'posList': makeReplacer(GML3.prototype.readFlatPosList),\n  },\n};\n\n/**\n * @const\n * @type {Object<string, Object<string, import(\"../xml.js\").Parser>>}\n */\nGML3.prototype.FLAT_LINEAR_RINGS_PARSERS = {\n  'http://www.opengis.net/gml': {\n    'interior': GML3.prototype.interiorParser,\n    'exterior': GML3.prototype.exteriorParser,\n  },\n};\n\n/**\n * @const\n * @type {Object<string, Object<string, import(\"../xml.js\").Parser>>}\n */\nGML3.prototype.GEOMETRY_PARSERS = {\n  'http://www.opengis.net/gml': {\n    'Point': makeReplacer(GMLBase.prototype.readPoint),\n    'MultiPoint': makeReplacer(GMLBase.prototype.readMultiPoint),\n    'LineString': makeReplacer(GMLBase.prototype.readLineString),\n    'MultiLineString': makeReplacer(GMLBase.prototype.readMultiLineString),\n    'LinearRing': makeReplacer(GMLBase.prototype.readLinearRing),\n    'Polygon': makeReplacer(GMLBase.prototype.readPolygon),\n    'MultiPolygon': makeReplacer(GMLBase.prototype.readMultiPolygon),\n    'Surface': makeReplacer(GML3.prototype.readSurface),\n    'MultiSurface': makeReplacer(GML3.prototype.readMultiSurface),\n    'Curve': makeReplacer(GML3.prototype.readCurve),\n    'MultiCurve': makeReplacer(GML3.prototype.readMultiCurve),\n    'Envelope': makeReplacer(GML3.prototype.readEnvelope),\n  },\n};\n\n/**\n * @const\n * @type {Object<string, Object<string, import(\"../xml.js\").Parser>>}\n */\nGML3.prototype.MULTICURVE_PARSERS = {\n  'http://www.opengis.net/gml': {\n    'curveMember': makeArrayPusher(GML3.prototype.curveMemberParser),\n    'curveMembers': makeArrayPusher(GML3.prototype.curveMemberParser),\n  },\n};\n\n/**\n * @const\n * @type {Object<string, Object<string, import(\"../xml.js\").Parser>>}\n */\nGML3.prototype.MULTISURFACE_PARSERS = {\n  'http://www.opengis.net/gml': {\n    'surfaceMember': makeArrayPusher(GML3.prototype.surfaceMemberParser),\n    'surfaceMembers': makeArrayPusher(GML3.prototype.surfaceMemberParser),\n  },\n};\n\n/**\n * @const\n * @type {Object<string, Object<string, import(\"../xml.js\").Parser>>}\n */\nGML3.prototype.CURVEMEMBER_PARSERS = {\n  'http://www.opengis.net/gml': {\n    'LineString': makeArrayPusher(GMLBase.prototype.readLineString),\n    'Curve': makeArrayPusher(GML3.prototype.readCurve),\n  },\n};\n\n/**\n * @const\n * @type {Object<string, Object<string, import(\"../xml.js\").Parser>>}\n */\nGML3.prototype.SURFACEMEMBER_PARSERS = {\n  'http://www.opengis.net/gml': {\n    'Polygon': makeArrayPusher(GMLBase.prototype.readPolygon),\n    'Surface': makeArrayPusher(GML3.prototype.readSurface),\n  },\n};\n\n/**\n * @const\n * @type {Object<string, Object<string, import(\"../xml.js\").Parser>>}\n */\nGML3.prototype.SURFACE_PARSERS = {\n  'http://www.opengis.net/gml': {\n    'patches': makeReplacer(GML3.prototype.readPatch),\n  },\n};\n\n/**\n * @const\n * @type {Object<string, Object<string, import(\"../xml.js\").Parser>>}\n */\nGML3.prototype.CURVE_PARSERS = {\n  'http://www.opengis.net/gml': {\n    'segments': makeReplacer(GML3.prototype.readSegment),\n  },\n};\n\n/**\n * @const\n * @type {Object<string, Object<string, import(\"../xml.js\").Parser>>}\n */\nGML3.prototype.ENVELOPE_PARSERS = {\n  'http://www.opengis.net/gml': {\n    'lowerCorner': makeArrayPusher(GML3.prototype.readFlatPosList),\n    'upperCorner': makeArrayPusher(GML3.prototype.readFlatPosList),\n  },\n};\n\n/**\n * @const\n * @type {Object<string, Object<string, import(\"../xml.js\").Parser>>}\n */\nGML3.prototype.PATCHES_PARSERS = {\n  'http://www.opengis.net/gml': {\n    'PolygonPatch': makeReplacer(GML3.prototype.readPolygonPatch),\n  },\n};\n\n/**\n * @const\n * @type {Object<string, Object<string, import(\"../xml.js\").Parser>>}\n */\nGML3.prototype.SEGMENTS_PARSERS = {\n  'http://www.opengis.net/gml': {\n    'LineStringSegment': makeReplacer(GML3.prototype.readLineStringSegment),\n  },\n};\n\n/**\n * Encode an array of features in GML 3.1.1 Simple Features.\n *\n * @function\n * @param {Array<import(\"../Feature.js\").default>} features Features.\n * @param {import(\"./Feature.js\").WriteOptions=} opt_options Options.\n * @return {string} Result.\n * @api\n */\nGML3.prototype.writeFeatures;\n\n/**\n * @type {Object<string, Object<string, import(\"../xml.js\").Serializer>>}\n */\nGML3.prototype.RING_SERIALIZERS = {\n  'http://www.opengis.net/gml': {\n    'exterior': makeChildAppender(GML3.prototype.writeRing),\n    'interior': makeChildAppender(GML3.prototype.writeRing),\n  },\n};\n\n/**\n * @type {Object<string, Object<string, import(\"../xml.js\").Serializer>>}\n */\nGML3.prototype.ENVELOPE_SERIALIZERS = {\n  'http://www.opengis.net/gml': {\n    'lowerCorner': makeChildAppender(writeStringTextNode),\n    'upperCorner': makeChildAppender(writeStringTextNode),\n  },\n};\n\n/**\n * @type {Object<string, Object<string, import(\"../xml.js\").Serializer>>}\n */\nGML3.prototype.SURFACEORPOLYGONMEMBER_SERIALIZERS = {\n  'http://www.opengis.net/gml': {\n    'surfaceMember': makeChildAppender(\n      GML3.prototype.writeSurfaceOrPolygonMember\n    ),\n    'polygonMember': makeChildAppender(\n      GML3.prototype.writeSurfaceOrPolygonMember\n    ),\n  },\n};\n\n/**\n * @type {Object<string, Object<string, import(\"../xml.js\").Serializer>>}\n */\nGML3.prototype.POINTMEMBER_SERIALIZERS = {\n  'http://www.opengis.net/gml': {\n    'pointMember': makeChildAppender(GML3.prototype.writePointMember),\n  },\n};\n\n/**\n * @type {Object<string, Object<string, import(\"../xml.js\").Serializer>>}\n */\nGML3.prototype.LINESTRINGORCURVEMEMBER_SERIALIZERS = {\n  'http://www.opengis.net/gml': {\n    'lineStringMember': makeChildAppender(\n      GML3.prototype.writeLineStringOrCurveMember\n    ),\n    'curveMember': makeChildAppender(\n      GML3.prototype.writeLineStringOrCurveMember\n    ),\n  },\n};\n\n/**\n * @type {Object<string, Object<string, import(\"../xml.js\").Serializer>>}\n */\nGML3.prototype.GEOMETRY_SERIALIZERS = {\n  'http://www.opengis.net/gml': {\n    'Curve': makeChildAppender(GML3.prototype.writeCurveOrLineString),\n    'MultiCurve': makeChildAppender(GML3.prototype.writeMultiCurveOrLineString),\n    'Point': makeChildAppender(GML3.prototype.writePoint),\n    'MultiPoint': makeChildAppender(GML3.prototype.writeMultiPoint),\n    'LineString': makeChildAppender(GML3.prototype.writeCurveOrLineString),\n    'MultiLineString': makeChildAppender(\n      GML3.prototype.writeMultiCurveOrLineString\n    ),\n    'LinearRing': makeChildAppender(GML3.prototype.writeLinearRing),\n    'Polygon': makeChildAppender(GML3.prototype.writeSurfaceOrPolygon),\n    'MultiPolygon': makeChildAppender(\n      GML3.prototype.writeMultiSurfaceOrPolygon\n    ),\n    'Surface': makeChildAppender(GML3.prototype.writeSurfaceOrPolygon),\n    'MultiSurface': makeChildAppender(\n      GML3.prototype.writeMultiSurfaceOrPolygon\n    ),\n    'Envelope': makeChildAppender(GML3.prototype.writeEnvelope),\n  },\n};\n\nexport default GML3;\n","/**\n * @module ol/format/filter/Filter\n */\n\n/**\n * @classdesc\n * Abstract class; normally only used for creating subclasses and not instantiated in apps.\n * Base class for WFS GetFeature filters.\n *\n * @abstract\n */\nclass Filter {\n  /**\n   * @param {!string} tagName The XML tag name for this filter.\n   */\n  constructor(tagName) {\n    /**\n     * @private\n     * @type {!string}\n     */\n    this.tagName_ = tagName;\n  }\n\n  /**\n   * The XML tag name for a filter.\n   * @returns {!string} Name.\n   */\n  getTagName() {\n    return this.tagName_;\n  }\n}\n\nexport default Filter;\n","/**\n * @module ol/format/filter/LogicalNary\n */\nimport Filter from './Filter.js';\nimport {assert} from '../../asserts.js';\n\n/**\n * @classdesc\n * Abstract class; normally only used for creating subclasses and not instantiated in apps.\n * Base class for WFS GetFeature n-ary logical filters.\n *\n * @abstract\n */\nclass LogicalNary extends Filter {\n  /**\n   * @param {!string} tagName The XML tag name for this filter.\n   * @param {Array<import(\"./Filter.js\").default>} conditions Conditions.\n   */\n  constructor(tagName, conditions) {\n    super(tagName);\n\n    /**\n     * @type {Array<import(\"./Filter.js\").default>}\n     */\n    this.conditions = conditions;\n    assert(this.conditions.length >= 2, 57); // At least 2 conditions are required.\n  }\n}\n\nexport default LogicalNary;\n","/**\n * @module ol/format/filter/And\n */\nimport LogicalNary from './LogicalNary.js';\n\n/**\n * @classdesc\n * Represents a logical `<And>` operator between two or more filter conditions.\n *\n * @abstract\n */\nclass And extends LogicalNary {\n  /**\n   * @param {...import(\"./Filter.js\").default} conditions Conditions.\n   */\n  constructor(conditions) {\n    super('And', Array.prototype.slice.call(arguments));\n  }\n}\n\nexport default And;\n","/**\n * @module ol/format/filter/Bbox\n */\nimport Filter from './Filter.js';\n\n/**\n * @classdesc\n * Represents a `<BBOX>` operator to test whether a geometry-valued property\n * intersects a fixed bounding box\n *\n * @api\n */\nclass Bbox extends Filter {\n  /**\n   * @param {!string} geometryName Geometry name to use.\n   * @param {!import(\"../../extent.js\").Extent} extent Extent.\n   * @param {string=} opt_srsName SRS name. No srsName attribute will be set\n   * on geometries when this is not provided.\n   */\n  constructor(geometryName, extent, opt_srsName) {\n    super('BBOX');\n\n    /**\n     * @type {!string}\n     */\n    this.geometryName = geometryName;\n\n    /**\n     * @type {import(\"../../extent.js\").Extent}\n     */\n    this.extent = extent;\n    if (extent.length !== 4) {\n      throw new Error(\n        'Expected an extent with four values ([minX, minY, maxX, maxY])'\n      );\n    }\n\n    /**\n     * @type {string|undefined}\n     */\n    this.srsName = opt_srsName;\n  }\n}\n\nexport default Bbox;\n","/**\n * @module ol/format/filter/Comparison\n */\nimport Filter from './Filter.js';\n\n/**\n * @classdesc\n * Abstract class; normally only used for creating subclasses and not instantiated in apps.\n * Base class for WFS GetFeature property comparison filters.\n *\n * @abstract\n */\nclass Comparison extends Filter {\n  /**\n   * @param {!string} tagName The XML tag name for this filter.\n   * @param {!string} propertyName Name of the context property to compare.\n   */\n  constructor(tagName, propertyName) {\n    super(tagName);\n\n    /**\n     * @type {!string}\n     */\n    this.propertyName = propertyName;\n  }\n}\n\nexport default Comparison;\n","/**\n * @module ol/format/filter/ComparisonBinary\n */\nimport Comparison from './Comparison.js';\n\n/**\n * @classdesc\n * Abstract class; normally only used for creating subclasses and not instantiated in apps.\n * Base class for WFS GetFeature property binary comparison filters.\n *\n * @abstract\n */\nclass ComparisonBinary extends Comparison {\n  /**\n   * @param {!string} tagName The XML tag name for this filter.\n   * @param {!string} propertyName Name of the context property to compare.\n   * @param {!(string|number)} expression The value to compare.\n   * @param {boolean=} opt_matchCase Case-sensitive?\n   */\n  constructor(tagName, propertyName, expression, opt_matchCase) {\n    super(tagName, propertyName);\n\n    /**\n     * @type {!(string|number)}\n     */\n    this.expression = expression;\n\n    /**\n     * @type {boolean|undefined}\n     */\n    this.matchCase = opt_matchCase;\n  }\n}\n\nexport default ComparisonBinary;\n","/**\n * @module ol/format/filter/EqualTo\n */\nimport ComparisonBinary from './ComparisonBinary.js';\n\n/**\n * @classdesc\n * Represents a `<PropertyIsEqualTo>` comparison operator.\n * @api\n */\nclass EqualTo extends ComparisonBinary {\n  /**\n   * @param {!string} propertyName Name of the context property to compare.\n   * @param {!(string|number)} expression The value to compare.\n   * @param {boolean=} opt_matchCase Case-sensitive?\n   */\n  constructor(propertyName, expression, opt_matchCase) {\n    super('PropertyIsEqualTo', propertyName, expression, opt_matchCase);\n  }\n}\n\nexport default EqualTo;\n","/**\n * @module ol/format/filter/IsLike\n */\nimport Comparison from './Comparison.js';\n\n/**\n * @classdesc\n * Represents a `<PropertyIsLike>` comparison operator.\n * @api\n */\nclass IsLike extends Comparison {\n  /**\n   * [constructor description]\n   * @param {!string} propertyName Name of the context property to compare.\n   * @param {!string} pattern Text pattern.\n   * @param {string=} opt_wildCard Pattern character which matches any sequence of\n   *    zero or more string characters. Default is '*'.\n   * @param {string=} opt_singleChar pattern character which matches any single\n   *    string character. Default is '.'.\n   * @param {string=} opt_escapeChar Escape character which can be used to escape\n   *    the pattern characters. Default is '!'.\n   * @param {boolean=} opt_matchCase Case-sensitive?\n   */\n  constructor(\n    propertyName,\n    pattern,\n    opt_wildCard,\n    opt_singleChar,\n    opt_escapeChar,\n    opt_matchCase\n  ) {\n    super('PropertyIsLike', propertyName);\n\n    /**\n     * @type {!string}\n     */\n    this.pattern = pattern;\n\n    /**\n     * @type {!string}\n     */\n    this.wildCard = opt_wildCard !== undefined ? opt_wildCard : '*';\n\n    /**\n     * @type {!string}\n     */\n    this.singleChar = opt_singleChar !== undefined ? opt_singleChar : '.';\n\n    /**\n     * @type {!string}\n     */\n    this.escapeChar = opt_escapeChar !== undefined ? opt_escapeChar : '!';\n\n    /**\n     * @type {boolean|undefined}\n     */\n    this.matchCase = opt_matchCase;\n  }\n}\n\nexport default IsLike;\n","/**\n * @module ol/format/filter\n */\nimport And from './filter/And.js';\nimport Bbox from './filter/Bbox.js';\nimport Contains from './filter/Contains.js';\nimport During from './filter/During.js';\nimport EqualTo from './filter/EqualTo.js';\nimport GreaterThan from './filter/GreaterThan.js';\nimport GreaterThanOrEqualTo from './filter/GreaterThanOrEqualTo.js';\nimport Intersects from './filter/Intersects.js';\nimport IsBetween from './filter/IsBetween.js';\nimport IsLike from './filter/IsLike.js';\nimport IsNull from './filter/IsNull.js';\nimport LessThan from './filter/LessThan.js';\nimport LessThanOrEqualTo from './filter/LessThanOrEqualTo.js';\nimport Not from './filter/Not.js';\nimport NotEqualTo from './filter/NotEqualTo.js';\nimport Or from './filter/Or.js';\nimport Within from './filter/Within.js';\n\n/**\n * Create a logical `<And>` operator between two or more filter conditions.\n *\n * @param {...import(\"./filter/Filter.js\").default} conditions Filter conditions.\n * @returns {!And} `<And>` operator.\n * @api\n */\nexport function and(conditions) {\n  const params = [null].concat(Array.prototype.slice.call(arguments));\n  return new (Function.prototype.bind.apply(And, params))();\n}\n\n/**\n * Create a logical `<Or>` operator between two or more filter conditions.\n *\n * @param {...import(\"./filter/Filter.js\").default} conditions Filter conditions.\n * @returns {!Or} `<Or>` operator.\n * @api\n */\nexport function or(conditions) {\n  const params = [null].concat(Array.prototype.slice.call(arguments));\n  return new (Function.prototype.bind.apply(Or, params))();\n}\n\n/**\n * Represents a logical `<Not>` operator for a filter condition.\n *\n * @param {!import(\"./filter/Filter.js\").default} condition Filter condition.\n * @returns {!Not} `<Not>` operator.\n * @api\n */\nexport function not(condition) {\n  return new Not(condition);\n}\n\n/**\n * Create a `<BBOX>` operator to test whether a geometry-valued property\n * intersects a fixed bounding box\n *\n * @param {!string} geometryName Geometry name to use.\n * @param {!import(\"../extent.js\").Extent} extent Extent.\n * @param {string=} opt_srsName SRS name. No srsName attribute will be\n *    set on geometries when this is not provided.\n * @returns {!Bbox} `<BBOX>` operator.\n * @api\n */\nexport function bbox(geometryName, extent, opt_srsName) {\n  return new Bbox(geometryName, extent, opt_srsName);\n}\n\n/**\n * Create a `<Contains>` operator to test whether a geometry-valued property\n * contains a given geometry.\n *\n * @param {!string} geometryName Geometry name to use.\n * @param {!import(\"../geom/Geometry.js\").default} geometry Geometry.\n * @param {string=} opt_srsName SRS name. No srsName attribute will be\n *    set on geometries when this is not provided.\n * @returns {!Contains} `<Contains>` operator.\n * @api\n */\nexport function contains(geometryName, geometry, opt_srsName) {\n  return new Contains(geometryName, geometry, opt_srsName);\n}\n\n/**\n * Create a `<Intersects>` operator to test whether a geometry-valued property\n * intersects a given geometry.\n *\n * @param {!string} geometryName Geometry name to use.\n * @param {!import(\"../geom/Geometry.js\").default} geometry Geometry.\n * @param {string=} opt_srsName SRS name. No srsName attribute will be\n *    set on geometries when this is not provided.\n * @returns {!Intersects} `<Intersects>` operator.\n * @api\n */\nexport function intersects(geometryName, geometry, opt_srsName) {\n  return new Intersects(geometryName, geometry, opt_srsName);\n}\n\n/**\n * Create a `<Within>` operator to test whether a geometry-valued property\n * is within a given geometry.\n *\n * @param {!string} geometryName Geometry name to use.\n * @param {!import(\"../geom/Geometry.js\").default} geometry Geometry.\n * @param {string=} opt_srsName SRS name. No srsName attribute will be\n *    set on geometries when this is not provided.\n * @returns {!Within} `<Within>` operator.\n * @api\n */\nexport function within(geometryName, geometry, opt_srsName) {\n  return new Within(geometryName, geometry, opt_srsName);\n}\n\n/**\n * Creates a `<PropertyIsEqualTo>` comparison operator.\n *\n * @param {!string} propertyName Name of the context property to compare.\n * @param {!(string|number)} expression The value to compare.\n * @param {boolean=} opt_matchCase Case-sensitive?\n * @returns {!EqualTo} `<PropertyIsEqualTo>` operator.\n * @api\n */\nexport function equalTo(propertyName, expression, opt_matchCase) {\n  return new EqualTo(propertyName, expression, opt_matchCase);\n}\n\n/**\n * Creates a `<PropertyIsNotEqualTo>` comparison operator.\n *\n * @param {!string} propertyName Name of the context property to compare.\n * @param {!(string|number)} expression The value to compare.\n * @param {boolean=} opt_matchCase Case-sensitive?\n * @returns {!NotEqualTo} `<PropertyIsNotEqualTo>` operator.\n * @api\n */\nexport function notEqualTo(propertyName, expression, opt_matchCase) {\n  return new NotEqualTo(propertyName, expression, opt_matchCase);\n}\n\n/**\n * Creates a `<PropertyIsLessThan>` comparison operator.\n *\n * @param {!string} propertyName Name of the context property to compare.\n * @param {!number} expression The value to compare.\n * @returns {!LessThan} `<PropertyIsLessThan>` operator.\n * @api\n */\nexport function lessThan(propertyName, expression) {\n  return new LessThan(propertyName, expression);\n}\n\n/**\n * Creates a `<PropertyIsLessThanOrEqualTo>` comparison operator.\n *\n * @param {!string} propertyName Name of the context property to compare.\n * @param {!number} expression The value to compare.\n * @returns {!LessThanOrEqualTo} `<PropertyIsLessThanOrEqualTo>` operator.\n * @api\n */\nexport function lessThanOrEqualTo(propertyName, expression) {\n  return new LessThanOrEqualTo(propertyName, expression);\n}\n\n/**\n * Creates a `<PropertyIsGreaterThan>` comparison operator.\n *\n * @param {!string} propertyName Name of the context property to compare.\n * @param {!number} expression The value to compare.\n * @returns {!GreaterThan} `<PropertyIsGreaterThan>` operator.\n * @api\n */\nexport function greaterThan(propertyName, expression) {\n  return new GreaterThan(propertyName, expression);\n}\n\n/**\n * Creates a `<PropertyIsGreaterThanOrEqualTo>` comparison operator.\n *\n * @param {!string} propertyName Name of the context property to compare.\n * @param {!number} expression The value to compare.\n * @returns {!GreaterThanOrEqualTo} `<PropertyIsGreaterThanOrEqualTo>` operator.\n * @api\n */\nexport function greaterThanOrEqualTo(propertyName, expression) {\n  return new GreaterThanOrEqualTo(propertyName, expression);\n}\n\n/**\n * Creates a `<PropertyIsNull>` comparison operator to test whether a property value\n * is null.\n *\n * @param {!string} propertyName Name of the context property to compare.\n * @returns {!IsNull} `<PropertyIsNull>` operator.\n * @api\n */\nexport function isNull(propertyName) {\n  return new IsNull(propertyName);\n}\n\n/**\n * Creates a `<PropertyIsBetween>` comparison operator to test whether an expression\n * value lies within a range given by a lower and upper bound (inclusive).\n *\n * @param {!string} propertyName Name of the context property to compare.\n * @param {!number} lowerBoundary The lower bound of the range.\n * @param {!number} upperBoundary The upper bound of the range.\n * @returns {!IsBetween} `<PropertyIsBetween>` operator.\n * @api\n */\nexport function between(propertyName, lowerBoundary, upperBoundary) {\n  return new IsBetween(propertyName, lowerBoundary, upperBoundary);\n}\n\n/**\n * Represents a `<PropertyIsLike>` comparison operator that matches a string property\n * value against a text pattern.\n *\n * @param {!string} propertyName Name of the context property to compare.\n * @param {!string} pattern Text pattern.\n * @param {string=} opt_wildCard Pattern character which matches any sequence of\n *    zero or more string characters. Default is '*'.\n * @param {string=} opt_singleChar pattern character which matches any single\n *    string character. Default is '.'.\n * @param {string=} opt_escapeChar Escape character which can be used to escape\n *    the pattern characters. Default is '!'.\n * @param {boolean=} opt_matchCase Case-sensitive?\n * @returns {!IsLike} `<PropertyIsLike>` operator.\n * @api\n */\nexport function like(\n  propertyName,\n  pattern,\n  opt_wildCard,\n  opt_singleChar,\n  opt_escapeChar,\n  opt_matchCase\n) {\n  return new IsLike(\n    propertyName,\n    pattern,\n    opt_wildCard,\n    opt_singleChar,\n    opt_escapeChar,\n    opt_matchCase\n  );\n}\n\n/**\n * Create a `<During>` temporal operator.\n *\n * @param {!string} propertyName Name of the context property to compare.\n * @param {!string} begin The begin date in ISO-8601 format.\n * @param {!string} end The end date in ISO-8601 format.\n * @returns {!During} `<During>` operator.\n * @api\n */\nexport function during(propertyName, begin, end) {\n  return new During(propertyName, begin, end);\n}\n","/**\n * @module ol/format/WFS\n */\nimport GML2 from './GML2.js';\nimport GML3 from './GML3.js';\nimport GMLBase, {GMLNS} from './GMLBase.js';\nimport XMLFeature from './XMLFeature.js';\nimport {\n  XML_SCHEMA_INSTANCE_URI,\n  createElementNS,\n  isDocument,\n  makeArrayPusher,\n  makeChildAppender,\n  makeObjectPropertySetter,\n  makeSimpleNodeFactory,\n  parse,\n  parseNode,\n  pushParseAndPop,\n  pushSerializeAndPop,\n} from '../xml.js';\nimport {and as andFilter, bbox as bboxFilter} from './filter.js';\nimport {assert} from '../asserts.js';\nimport {assign} from '../obj.js';\nimport {get as getProjection} from '../proj.js';\nimport {\n  readNonNegativeInteger,\n  readNonNegativeIntegerString,\n  writeStringTextNode,\n} from './xsd.js';\n\n/**\n * @const\n * @type {Object<string, Object<string, import(\"../xml.js\").Parser>>}\n */\nconst FEATURE_COLLECTION_PARSERS = {\n  'http://www.opengis.net/gml': {\n    'boundedBy': makeObjectPropertySetter(\n      GMLBase.prototype.readGeometryElement,\n      'bounds'\n    ),\n  },\n};\n\n/**\n * @const\n * @type {Object<string, Object<string, import(\"../xml.js\").Parser>>}\n */\nconst TRANSACTION_SUMMARY_PARSERS = {\n  'http://www.opengis.net/wfs': {\n    'totalInserted': makeObjectPropertySetter(readNonNegativeInteger),\n    'totalUpdated': makeObjectPropertySetter(readNonNegativeInteger),\n    'totalDeleted': makeObjectPropertySetter(readNonNegativeInteger),\n  },\n};\n\n/**\n * @const\n * @type {Object<string, Object<string, import(\"../xml.js\").Parser>>}\n */\nconst TRANSACTION_RESPONSE_PARSERS = {\n  'http://www.opengis.net/wfs': {\n    'TransactionSummary': makeObjectPropertySetter(\n      readTransactionSummary,\n      'transactionSummary'\n    ),\n    'InsertResults': makeObjectPropertySetter(readInsertResults, 'insertIds'),\n  },\n};\n\n/**\n * @type {Object<string, Object<string, import(\"../xml.js\").Serializer>>}\n */\nconst QUERY_SERIALIZERS = {\n  'http://www.opengis.net/wfs': {\n    'PropertyName': makeChildAppender(writeStringTextNode),\n  },\n};\n\n/**\n * @type {Object<string, Object<string, import(\"../xml.js\").Serializer>>}\n */\nconst TRANSACTION_SERIALIZERS = {\n  'http://www.opengis.net/wfs': {\n    'Insert': makeChildAppender(writeFeature),\n    'Update': makeChildAppender(writeUpdate),\n    'Delete': makeChildAppender(writeDelete),\n    'Property': makeChildAppender(writeProperty),\n    'Native': makeChildAppender(writeNative),\n  },\n};\n\n/**\n * @typedef {Object} Options\n * @property {Object<string, string>|string} [featureNS] The namespace URI used for features.\n * @property {Array<string>|string} [featureType] The feature type to parse. Only used for read operations.\n * @property {GMLBase} [gmlFormat] The GML format to use to parse the response. Default is `ol/format/GML3`.\n * @property {string} [schemaLocation] Optional schemaLocation to use for serialization, this will override the default.\n */\n\n/**\n * @typedef {Object} WriteGetFeatureOptions\n * @property {string} featureNS The namespace URI used for features.\n * @property {string} featurePrefix The prefix for the feature namespace.\n * @property {Array<string>} featureTypes The feature type names.\n * @property {string} [srsName] SRS name. No srsName attribute will be set on\n * geometries when this is not provided.\n * @property {string} [handle] Handle.\n * @property {string} [outputFormat] Output format.\n * @property {number} [maxFeatures] Maximum number of features to fetch.\n * @property {string} [geometryName] Geometry name to use in a BBOX filter.\n * @property {Array<string>} [propertyNames] Optional list of property names to serialize.\n * @property {string} [viewParams] viewParams GeoServer vendor parameter.\n * @property {number} [startIndex] Start index to use for WFS paging. This is a\n * WFS 2.0 feature backported to WFS 1.1.0 by some Web Feature Services.\n * @property {number} [count] Number of features to retrieve when paging. This is a\n * WFS 2.0 feature backported to WFS 1.1.0 by some Web Feature Services. Please note that some\n * Web Feature Services have repurposed `maxfeatures` instead.\n * @property {import(\"../extent.js\").Extent} [bbox] Extent to use for the BBOX filter.\n * @property {import(\"./filter/Filter.js\").default} [filter] Filter condition. See\n * {@link module:ol/format/Filter} for more information.\n * @property {string} [resultType] Indicates what response should be returned,\n * E.g. `hits` only includes the `numberOfFeatures` attribute in the response and no features.\n */\n\n/**\n * @typedef {Object} WriteTransactionOptions\n * @property {string} featureNS The namespace URI used for features.\n * @property {string} featurePrefix The prefix for the feature namespace.\n * @property {string} featureType The feature type name.\n * @property {string} [srsName] SRS name. No srsName attribute will be set on\n * geometries when this is not provided.\n * @property {string} [handle] Handle.\n * @property {boolean} [hasZ] Must be set to true if the transaction is for\n * a 3D layer. This will allow the Z coordinate to be included in the transaction.\n * @property {Array<Object>} nativeElements Native elements. Currently not supported.\n * @property {import(\"./GMLBase.js\").Options} [gmlOptions] GML options for the WFS transaction writer.\n * @property {string} [version='1.1.0'] WFS version to use for the transaction. Can be either `1.0.0` or `1.1.0`.\n */\n\n/**\n * Number of features; bounds/extent.\n * @typedef {Object} FeatureCollectionMetadata\n * @property {number} numberOfFeatures\n * @property {import(\"../extent.js\").Extent} bounds\n */\n\n/**\n * Total deleted; total inserted; total updated; array of insert ids.\n * @typedef {Object} TransactionResponse\n * @property {number} totalDeleted\n * @property {number} totalInserted\n * @property {number} totalUpdated\n * @property {Array<string>} insertIds\n */\n\n/**\n * @type {string}\n */\nconst FEATURE_PREFIX = 'feature';\n\n/**\n * @type {string}\n */\nconst XMLNS = 'http://www.w3.org/2000/xmlns/';\n\n/**\n * @type {string}\n */\nconst OGCNS = 'http://www.opengis.net/ogc';\n\n/**\n * @type {string}\n */\nconst WFSNS = 'http://www.opengis.net/wfs';\n\n/**\n * @type {string}\n */\nconst FESNS = 'http://www.opengis.net/fes';\n\n/**\n * @type {Object<string, string>}\n */\nconst SCHEMA_LOCATIONS = {\n  '1.1.0':\n    'http://www.opengis.net/wfs http://schemas.opengis.net/wfs/1.1.0/wfs.xsd',\n  '1.0.0':\n    'http://www.opengis.net/wfs http://schemas.opengis.net/wfs/1.0.0/wfs.xsd',\n};\n\n/**\n * @const\n * @type {string}\n */\nconst DEFAULT_VERSION = '1.1.0';\n\n/**\n * @classdesc\n * Feature format for reading and writing data in the WFS format.\n * By default, supports WFS version 1.1.0. You can pass a GML format\n * as option if you want to read a WFS that contains GML2 (WFS 1.0.0).\n * Also see {@link module:ol/format/GMLBase~GMLBase} which is used by this format.\n *\n * @api\n */\nclass WFS extends XMLFeature {\n  /**\n   * @param {Options=} opt_options Optional configuration object.\n   */\n  constructor(opt_options) {\n    super();\n\n    const options = opt_options ? opt_options : {};\n\n    /**\n     * @private\n     * @type {Array<string>|string|undefined}\n     */\n    this.featureType_ = options.featureType;\n\n    /**\n     * @private\n     * @type {Object<string, string>|string|undefined}\n     */\n    this.featureNS_ = options.featureNS;\n\n    /**\n     * @private\n     * @type {GMLBase}\n     */\n    this.gmlFormat_ = options.gmlFormat ? options.gmlFormat : new GML3();\n\n    /**\n     * @private\n     * @type {string}\n     */\n    this.schemaLocation_ = options.schemaLocation\n      ? options.schemaLocation\n      : SCHEMA_LOCATIONS[DEFAULT_VERSION];\n  }\n\n  /**\n   * @return {Array<string>|string|undefined} featureType\n   */\n  getFeatureType() {\n    return this.featureType_;\n  }\n\n  /**\n   * @param {Array<string>|string|undefined} featureType Feature type(s) to parse.\n   */\n  setFeatureType(featureType) {\n    this.featureType_ = featureType;\n  }\n\n  /**\n   * @protected\n   * @param {Element} node Node.\n   * @param {import(\"./Feature.js\").ReadOptions=} opt_options Options.\n   * @return {Array<import(\"../Feature.js\").default>} Features.\n   */\n  readFeaturesFromNode(node, opt_options) {\n    /** @type {import(\"../xml.js\").NodeStackItem} */\n    const context = {\n      node: node,\n    };\n    assign(context, {\n      'featureType': this.featureType_,\n      'featureNS': this.featureNS_,\n    });\n\n    assign(context, this.getReadOptions(node, opt_options ? opt_options : {}));\n    const objectStack = [context];\n    this.gmlFormat_.FEATURE_COLLECTION_PARSERS[GMLNS][\n      'featureMember'\n    ] = makeArrayPusher(GMLBase.prototype.readFeaturesInternal);\n    let features = pushParseAndPop(\n      [],\n      this.gmlFormat_.FEATURE_COLLECTION_PARSERS,\n      node,\n      objectStack,\n      this.gmlFormat_\n    );\n    if (!features) {\n      features = [];\n    }\n    return features;\n  }\n\n  /**\n   * Read transaction response of the source.\n   *\n   * @param {Document|Element|Object|string} source Source.\n   * @return {TransactionResponse|undefined} Transaction response.\n   * @api\n   */\n  readTransactionResponse(source) {\n    if (!source) {\n      return undefined;\n    } else if (typeof source === 'string') {\n      const doc = parse(source);\n      return this.readTransactionResponseFromDocument(doc);\n    } else if (isDocument(source)) {\n      return this.readTransactionResponseFromDocument(\n        /** @type {Document} */ (source)\n      );\n    } else {\n      return this.readTransactionResponseFromNode(\n        /** @type {Element} */ (source)\n      );\n    }\n  }\n\n  /**\n   * Read feature collection metadata of the source.\n   *\n   * @param {Document|Element|Object|string} source Source.\n   * @return {FeatureCollectionMetadata|undefined}\n   *     FeatureCollection metadata.\n   * @api\n   */\n  readFeatureCollectionMetadata(source) {\n    if (!source) {\n      return undefined;\n    } else if (typeof source === 'string') {\n      const doc = parse(source);\n      return this.readFeatureCollectionMetadataFromDocument(doc);\n    } else if (isDocument(source)) {\n      return this.readFeatureCollectionMetadataFromDocument(\n        /** @type {Document} */ (source)\n      );\n    } else {\n      return this.readFeatureCollectionMetadataFromNode(\n        /** @type {Element} */ (source)\n      );\n    }\n  }\n\n  /**\n   * @param {Document} doc Document.\n   * @return {FeatureCollectionMetadata|undefined}\n   *     FeatureCollection metadata.\n   */\n  readFeatureCollectionMetadataFromDocument(doc) {\n    for (let n = /** @type {Node} */ (doc.firstChild); n; n = n.nextSibling) {\n      if (n.nodeType == Node.ELEMENT_NODE) {\n        return this.readFeatureCollectionMetadataFromNode(\n          /** @type {Element} */ (n)\n        );\n      }\n    }\n    return undefined;\n  }\n\n  /**\n   * @param {Element} node Node.\n   * @return {FeatureCollectionMetadata|undefined}\n   *     FeatureCollection metadata.\n   */\n  readFeatureCollectionMetadataFromNode(node) {\n    const result = {};\n    const value = readNonNegativeIntegerString(\n      node.getAttribute('numberOfFeatures')\n    );\n    result['numberOfFeatures'] = value;\n    return pushParseAndPop(\n      /** @type {FeatureCollectionMetadata} */ (result),\n      FEATURE_COLLECTION_PARSERS,\n      node,\n      [],\n      this.gmlFormat_\n    );\n  }\n\n  /**\n   * @param {Document} doc Document.\n   * @return {TransactionResponse|undefined} Transaction response.\n   */\n  readTransactionResponseFromDocument(doc) {\n    for (let n = /** @type {Node} */ (doc.firstChild); n; n = n.nextSibling) {\n      if (n.nodeType == Node.ELEMENT_NODE) {\n        return this.readTransactionResponseFromNode(/** @type {Element} */ (n));\n      }\n    }\n    return undefined;\n  }\n\n  /**\n   * @param {Element} node Node.\n   * @return {TransactionResponse|undefined} Transaction response.\n   */\n  readTransactionResponseFromNode(node) {\n    return pushParseAndPop(\n      /** @type {TransactionResponse} */ ({}),\n      TRANSACTION_RESPONSE_PARSERS,\n      node,\n      []\n    );\n  }\n\n  /**\n   * Encode format as WFS `GetFeature` and return the Node.\n   *\n   * @param {WriteGetFeatureOptions} options Options.\n   * @return {Node} Result.\n   * @api\n   */\n  writeGetFeature(options) {\n    const node = createElementNS(WFSNS, 'GetFeature');\n    node.setAttribute('service', 'WFS');\n    node.setAttribute('version', '1.1.0');\n    let filter;\n    if (options) {\n      if (options.handle) {\n        node.setAttribute('handle', options.handle);\n      }\n      if (options.outputFormat) {\n        node.setAttribute('outputFormat', options.outputFormat);\n      }\n      if (options.maxFeatures !== undefined) {\n        node.setAttribute('maxFeatures', String(options.maxFeatures));\n      }\n      if (options.resultType) {\n        node.setAttribute('resultType', options.resultType);\n      }\n      if (options.startIndex !== undefined) {\n        node.setAttribute('startIndex', String(options.startIndex));\n      }\n      if (options.count !== undefined) {\n        node.setAttribute('count', String(options.count));\n      }\n      if (options.viewParams !== undefined) {\n        node.setAttribute('viewParams', options.viewParams);\n      }\n      filter = options.filter;\n      if (options.bbox) {\n        assert(options.geometryName, 12); // `options.geometryName` must also be provided when `options.bbox` is set\n        const bbox = bboxFilter(\n          /** @type {string} */ (options.geometryName),\n          options.bbox,\n          options.srsName\n        );\n        if (filter) {\n          // if bbox and filter are both set, combine the two into a single filter\n          filter = andFilter(filter, bbox);\n        } else {\n          filter = bbox;\n        }\n      }\n    }\n    node.setAttributeNS(\n      XML_SCHEMA_INSTANCE_URI,\n      'xsi:schemaLocation',\n      this.schemaLocation_\n    );\n    /** @type {import(\"../xml.js\").NodeStackItem} */\n    const context = {\n      node: node,\n    };\n    assign(context, {\n      'srsName': options.srsName,\n      'featureNS': options.featureNS ? options.featureNS : this.featureNS_,\n      'featurePrefix': options.featurePrefix,\n      'geometryName': options.geometryName,\n      'filter': filter,\n      'propertyNames': options.propertyNames ? options.propertyNames : [],\n    });\n\n    assert(Array.isArray(options.featureTypes), 11); // `options.featureTypes` should be an Array\n    writeGetFeature(\n      node,\n      /** @type {!Array<string>} */ (options.featureTypes),\n      [context]\n    );\n    return node;\n  }\n\n  /**\n   * Encode format as WFS `Transaction` and return the Node.\n   *\n   * @param {Array<import(\"../Feature.js\").default>} inserts The features to insert.\n   * @param {Array<import(\"../Feature.js\").default>} updates The features to update.\n   * @param {Array<import(\"../Feature.js\").default>} deletes The features to delete.\n   * @param {WriteTransactionOptions} options Write options.\n   * @return {Node} Result.\n   * @api\n   */\n  writeTransaction(inserts, updates, deletes, options) {\n    const objectStack = [];\n    const node = createElementNS(WFSNS, 'Transaction');\n    const version = options.version ? options.version : DEFAULT_VERSION;\n    const gmlVersion = version === '1.0.0' ? 2 : 3;\n    node.setAttribute('service', 'WFS');\n    node.setAttribute('version', version);\n    let baseObj;\n    /** @type {import(\"../xml.js\").NodeStackItem} */\n    let obj;\n    if (options) {\n      baseObj = options.gmlOptions ? options.gmlOptions : {};\n      if (options.handle) {\n        node.setAttribute('handle', options.handle);\n      }\n    }\n    const schemaLocation = SCHEMA_LOCATIONS[version];\n    node.setAttributeNS(\n      XML_SCHEMA_INSTANCE_URI,\n      'xsi:schemaLocation',\n      schemaLocation\n    );\n    const featurePrefix = options.featurePrefix\n      ? options.featurePrefix\n      : FEATURE_PREFIX;\n    if (inserts) {\n      obj = assign(\n        {node: node},\n        {\n          'featureNS': options.featureNS,\n          'featureType': options.featureType,\n          'featurePrefix': featurePrefix,\n          'gmlVersion': gmlVersion,\n          'hasZ': options.hasZ,\n          'srsName': options.srsName,\n        }\n      );\n      assign(obj, baseObj);\n      pushSerializeAndPop(\n        obj,\n        TRANSACTION_SERIALIZERS,\n        makeSimpleNodeFactory('Insert'),\n        inserts,\n        objectStack\n      );\n    }\n    if (updates) {\n      obj = assign(\n        {node: node},\n        {\n          'featureNS': options.featureNS,\n          'featureType': options.featureType,\n          'featurePrefix': featurePrefix,\n          'gmlVersion': gmlVersion,\n          'hasZ': options.hasZ,\n          'srsName': options.srsName,\n        }\n      );\n      assign(obj, baseObj);\n      pushSerializeAndPop(\n        obj,\n        TRANSACTION_SERIALIZERS,\n        makeSimpleNodeFactory('Update'),\n        updates,\n        objectStack\n      );\n    }\n    if (deletes) {\n      pushSerializeAndPop(\n        {\n          node: node,\n          'featureNS': options.featureNS,\n          'featureType': options.featureType,\n          'featurePrefix': featurePrefix,\n          'gmlVersion': gmlVersion,\n          'srsName': options.srsName,\n        },\n        TRANSACTION_SERIALIZERS,\n        makeSimpleNodeFactory('Delete'),\n        deletes,\n        objectStack\n      );\n    }\n    if (options.nativeElements) {\n      pushSerializeAndPop(\n        {\n          node: node,\n          'featureNS': options.featureNS,\n          'featureType': options.featureType,\n          'featurePrefix': featurePrefix,\n          'gmlVersion': gmlVersion,\n          'srsName': options.srsName,\n        },\n        TRANSACTION_SERIALIZERS,\n        makeSimpleNodeFactory('Native'),\n        options.nativeElements,\n        objectStack\n      );\n    }\n    return node;\n  }\n\n  /**\n   * @param {Document} doc Document.\n   * @return {import(\"../proj/Projection.js\").default} Projection.\n   */\n  readProjectionFromDocument(doc) {\n    for (let n = doc.firstChild; n; n = n.nextSibling) {\n      if (n.nodeType == Node.ELEMENT_NODE) {\n        return this.readProjectionFromNode(/** @type {Element} */ (n));\n      }\n    }\n    return null;\n  }\n\n  /**\n   * @param {Element} node Node.\n   * @return {import(\"../proj/Projection.js\").default} Projection.\n   */\n  readProjectionFromNode(node) {\n    if (node.firstElementChild && node.firstElementChild.firstElementChild) {\n      node = node.firstElementChild.firstElementChild;\n      for (let n = node.firstElementChild; n; n = n.nextElementSibling) {\n        if (\n          !(\n            n.childNodes.length === 0 ||\n            (n.childNodes.length === 1 && n.firstChild.nodeType === 3)\n          )\n        ) {\n          const objectStack = [{}];\n          this.gmlFormat_.readGeometryElement(n, objectStack);\n          return getProjection(objectStack.pop().srsName);\n        }\n      }\n    }\n\n    return null;\n  }\n}\n\n/**\n * @param {Element} node Node.\n * @param {Array<*>} objectStack Object stack.\n * @return {Object|undefined} Transaction Summary.\n */\nfunction readTransactionSummary(node, objectStack) {\n  return pushParseAndPop({}, TRANSACTION_SUMMARY_PARSERS, node, objectStack);\n}\n\n/**\n * @const\n * @type {Object<string, Object<string, import(\"../xml.js\").Parser>>}\n */\nconst OGC_FID_PARSERS = {\n  'http://www.opengis.net/ogc': {\n    'FeatureId': makeArrayPusher(function (node, objectStack) {\n      return node.getAttribute('fid');\n    }),\n  },\n};\n\n/**\n * @param {Element} node Node.\n * @param {Array<*>} objectStack Object stack.\n */\nfunction fidParser(node, objectStack) {\n  parseNode(OGC_FID_PARSERS, node, objectStack);\n}\n\n/**\n * @const\n * @type {Object<string, Object<string, import(\"../xml.js\").Parser>>}\n */\nconst INSERT_RESULTS_PARSERS = {\n  'http://www.opengis.net/wfs': {\n    'Feature': fidParser,\n  },\n};\n\n/**\n * @param {Element} node Node.\n * @param {Array<*>} objectStack Object stack.\n * @return {Array<string>|undefined} Insert results.\n */\nfunction readInsertResults(node, objectStack) {\n  return pushParseAndPop([], INSERT_RESULTS_PARSERS, node, objectStack);\n}\n\n/**\n * @param {Element} node Node.\n * @param {import(\"../Feature.js\").default} feature Feature.\n * @param {Array<*>} objectStack Node stack.\n */\nfunction writeFeature(node, feature, objectStack) {\n  const context = objectStack[objectStack.length - 1];\n  const featureType = context['featureType'];\n  const featureNS = context['featureNS'];\n  const gmlVersion = context['gmlVersion'];\n  const child = createElementNS(featureNS, featureType);\n  node.appendChild(child);\n  if (gmlVersion === 2) {\n    GML2.prototype.writeFeatureElement(child, feature, objectStack);\n  } else {\n    GML3.prototype.writeFeatureElement(child, feature, objectStack);\n  }\n}\n\n/**\n * @param {Node} node Node.\n * @param {number|string} fid Feature identifier.\n * @param {Array<*>} objectStack Node stack.\n */\nfunction writeOgcFidFilter(node, fid, objectStack) {\n  const filter = createElementNS(OGCNS, 'Filter');\n  const child = createElementNS(OGCNS, 'FeatureId');\n  filter.appendChild(child);\n  child.setAttribute('fid', /** @type {string} */ (fid));\n  node.appendChild(filter);\n}\n\n/**\n * @param {string|undefined} featurePrefix The prefix of the feature.\n * @param {string} featureType The type of the feature.\n * @returns {string} The value of the typeName property.\n */\nfunction getTypeName(featurePrefix, featureType) {\n  featurePrefix = featurePrefix ? featurePrefix : FEATURE_PREFIX;\n  const prefix = featurePrefix + ':';\n  // The featureType already contains the prefix.\n  if (featureType.indexOf(prefix) === 0) {\n    return featureType;\n  } else {\n    return prefix + featureType;\n  }\n}\n\n/**\n * @param {Element} node Node.\n * @param {import(\"../Feature.js\").default} feature Feature.\n * @param {Array<*>} objectStack Node stack.\n */\nfunction writeDelete(node, feature, objectStack) {\n  const context = objectStack[objectStack.length - 1];\n  assert(feature.getId() !== undefined, 26); // Features must have an id set\n  const featureType = context['featureType'];\n  const featurePrefix = context['featurePrefix'];\n  const featureNS = context['featureNS'];\n  const typeName = getTypeName(featurePrefix, featureType);\n  node.setAttribute('typeName', typeName);\n  node.setAttributeNS(XMLNS, 'xmlns:' + featurePrefix, featureNS);\n  const fid = feature.getId();\n  if (fid !== undefined) {\n    writeOgcFidFilter(node, fid, objectStack);\n  }\n}\n\n/**\n * @param {Element} node Node.\n * @param {import(\"../Feature.js\").default} feature Feature.\n * @param {Array<*>} objectStack Node stack.\n */\nfunction writeUpdate(node, feature, objectStack) {\n  const context = objectStack[objectStack.length - 1];\n  assert(feature.getId() !== undefined, 27); // Features must have an id set\n  const featureType = context['featureType'];\n  const featurePrefix = context['featurePrefix'];\n  const featureNS = context['featureNS'];\n  const typeName = getTypeName(featurePrefix, featureType);\n  const geometryName = feature.getGeometryName();\n  node.setAttribute('typeName', typeName);\n  node.setAttributeNS(XMLNS, 'xmlns:' + featurePrefix, featureNS);\n  const fid = feature.getId();\n  if (fid !== undefined) {\n    const keys = feature.getKeys();\n    const values = [];\n    for (let i = 0, ii = keys.length; i < ii; i++) {\n      const value = feature.get(keys[i]);\n      if (value !== undefined) {\n        let name = keys[i];\n        if (\n          value &&\n          typeof (/** @type {?} */ (value).getSimplifiedGeometry) === 'function'\n        ) {\n          name = geometryName;\n        }\n        values.push({name: name, value: value});\n      }\n    }\n    pushSerializeAndPop(\n      /** @type {import(\"../xml.js\").NodeStackItem} */ ({\n        'gmlVersion': context['gmlVersion'],\n        node: node,\n        'hasZ': context['hasZ'],\n        'srsName': context['srsName'],\n      }),\n      TRANSACTION_SERIALIZERS,\n      makeSimpleNodeFactory('Property'),\n      values,\n      objectStack\n    );\n    writeOgcFidFilter(node, fid, objectStack);\n  }\n}\n\n/**\n * @param {Node} node Node.\n * @param {Object} pair Property name and value.\n * @param {Array<*>} objectStack Node stack.\n */\nfunction writeProperty(node, pair, objectStack) {\n  const name = createElementNS(WFSNS, 'Name');\n  const context = objectStack[objectStack.length - 1];\n  const gmlVersion = context['gmlVersion'];\n  node.appendChild(name);\n  writeStringTextNode(name, pair.name);\n  if (pair.value !== undefined && pair.value !== null) {\n    const value = createElementNS(WFSNS, 'Value');\n    node.appendChild(value);\n    if (\n      pair.value &&\n      typeof (/** @type {?} */ (pair.value).getSimplifiedGeometry) ===\n        'function'\n    ) {\n      if (gmlVersion === 2) {\n        GML2.prototype.writeGeometryElement(value, pair.value, objectStack);\n      } else {\n        GML3.prototype.writeGeometryElement(value, pair.value, objectStack);\n      }\n    } else {\n      writeStringTextNode(value, pair.value);\n    }\n  }\n}\n\n/**\n * @param {Element} node Node.\n * @param {{vendorId: string, safeToIgnore: boolean, value: string}} nativeElement The native element.\n * @param {Array<*>} objectStack Node stack.\n */\nfunction writeNative(node, nativeElement, objectStack) {\n  if (nativeElement.vendorId) {\n    node.setAttribute('vendorId', nativeElement.vendorId);\n  }\n  if (nativeElement.safeToIgnore !== undefined) {\n    node.setAttribute('safeToIgnore', String(nativeElement.safeToIgnore));\n  }\n  if (nativeElement.value !== undefined) {\n    writeStringTextNode(node, nativeElement.value);\n  }\n}\n\n/**\n * @type {Object<string, Object<string, import(\"../xml.js\").Serializer>>}\n */\nconst GETFEATURE_SERIALIZERS = {\n  'http://www.opengis.net/wfs': {\n    'Query': makeChildAppender(writeQuery),\n  },\n  'http://www.opengis.net/ogc': {\n    'During': makeChildAppender(writeDuringFilter),\n    'And': makeChildAppender(writeLogicalFilter),\n    'Or': makeChildAppender(writeLogicalFilter),\n    'Not': makeChildAppender(writeNotFilter),\n    'BBOX': makeChildAppender(writeBboxFilter),\n    'Contains': makeChildAppender(writeContainsFilter),\n    'Intersects': makeChildAppender(writeIntersectsFilter),\n    'Within': makeChildAppender(writeWithinFilter),\n    'PropertyIsEqualTo': makeChildAppender(writeComparisonFilter),\n    'PropertyIsNotEqualTo': makeChildAppender(writeComparisonFilter),\n    'PropertyIsLessThan': makeChildAppender(writeComparisonFilter),\n    'PropertyIsLessThanOrEqualTo': makeChildAppender(writeComparisonFilter),\n    'PropertyIsGreaterThan': makeChildAppender(writeComparisonFilter),\n    'PropertyIsGreaterThanOrEqualTo': makeChildAppender(writeComparisonFilter),\n    'PropertyIsNull': makeChildAppender(writeIsNullFilter),\n    'PropertyIsBetween': makeChildAppender(writeIsBetweenFilter),\n    'PropertyIsLike': makeChildAppender(writeIsLikeFilter),\n  },\n};\n\n/**\n * @param {Element} node Node.\n * @param {string} featureType Feature type.\n * @param {Array<*>} objectStack Node stack.\n */\nfunction writeQuery(node, featureType, objectStack) {\n  const context = /** @type {Object} */ (objectStack[objectStack.length - 1]);\n  const featurePrefix = context['featurePrefix'];\n  const featureNS = context['featureNS'];\n  const propertyNames = context['propertyNames'];\n  const srsName = context['srsName'];\n  let typeName;\n  // If feature prefix is not defined, we must not use the default prefix.\n  if (featurePrefix) {\n    typeName = getTypeName(featurePrefix, featureType);\n  } else {\n    typeName = featureType;\n  }\n  node.setAttribute('typeName', typeName);\n  if (srsName) {\n    node.setAttribute('srsName', srsName);\n  }\n  if (featureNS) {\n    node.setAttributeNS(XMLNS, 'xmlns:' + featurePrefix, featureNS);\n  }\n  const item = /** @type {import(\"../xml.js\").NodeStackItem} */ (assign(\n    {},\n    context\n  ));\n  item.node = node;\n  pushSerializeAndPop(\n    item,\n    QUERY_SERIALIZERS,\n    makeSimpleNodeFactory('PropertyName'),\n    propertyNames,\n    objectStack\n  );\n  const filter = context['filter'];\n  if (filter) {\n    const child = createElementNS(OGCNS, 'Filter');\n    node.appendChild(child);\n    writeFilterCondition(child, filter, objectStack);\n  }\n}\n\n/**\n * @param {Node} node Node.\n * @param {import(\"./filter/Filter.js\").default} filter Filter.\n * @param {Array<*>} objectStack Node stack.\n */\nfunction writeFilterCondition(node, filter, objectStack) {\n  /** @type {import(\"../xml.js\").NodeStackItem} */\n  const item = {node: node};\n  pushSerializeAndPop(\n    item,\n    GETFEATURE_SERIALIZERS,\n    makeSimpleNodeFactory(filter.getTagName()),\n    [filter],\n    objectStack\n  );\n}\n\n/**\n * @param {Node} node Node.\n * @param {import(\"./filter/Bbox.js\").default} filter Filter.\n * @param {Array<*>} objectStack Node stack.\n */\nfunction writeBboxFilter(node, filter, objectStack) {\n  const context = objectStack[objectStack.length - 1];\n  context['srsName'] = filter.srsName;\n\n  writeOgcPropertyName(node, filter.geometryName);\n  GML3.prototype.writeGeometryElement(node, filter.extent, objectStack);\n}\n\n/**\n * @param {Node} node Node.\n * @param {import(\"./filter/Contains.js\").default} filter Filter.\n * @param {Array<*>} objectStack Node stack.\n */\nfunction writeContainsFilter(node, filter, objectStack) {\n  const context = objectStack[objectStack.length - 1];\n  context['srsName'] = filter.srsName;\n\n  writeOgcPropertyName(node, filter.geometryName);\n  GML3.prototype.writeGeometryElement(node, filter.geometry, objectStack);\n}\n\n/**\n * @param {Node} node Node.\n * @param {import(\"./filter/Intersects.js\").default} filter Filter.\n * @param {Array<*>} objectStack Node stack.\n */\nfunction writeIntersectsFilter(node, filter, objectStack) {\n  const context = objectStack[objectStack.length - 1];\n  context['srsName'] = filter.srsName;\n\n  writeOgcPropertyName(node, filter.geometryName);\n  GML3.prototype.writeGeometryElement(node, filter.geometry, objectStack);\n}\n\n/**\n * @param {Node} node Node.\n * @param {import(\"./filter/Within.js\").default} filter Filter.\n * @param {Array<*>} objectStack Node stack.\n */\nfunction writeWithinFilter(node, filter, objectStack) {\n  const context = objectStack[objectStack.length - 1];\n  context['srsName'] = filter.srsName;\n\n  writeOgcPropertyName(node, filter.geometryName);\n  GML3.prototype.writeGeometryElement(node, filter.geometry, objectStack);\n}\n\n/**\n * @param {Node} node Node.\n * @param {import(\"./filter/During.js\").default} filter Filter.\n * @param {Array<*>} objectStack Node stack.\n */\nfunction writeDuringFilter(node, filter, objectStack) {\n  const valueReference = createElementNS(FESNS, 'ValueReference');\n  writeStringTextNode(valueReference, filter.propertyName);\n  node.appendChild(valueReference);\n\n  const timePeriod = createElementNS(GMLNS, 'TimePeriod');\n\n  node.appendChild(timePeriod);\n\n  const begin = createElementNS(GMLNS, 'begin');\n  timePeriod.appendChild(begin);\n  writeTimeInstant(begin, filter.begin);\n\n  const end = createElementNS(GMLNS, 'end');\n  timePeriod.appendChild(end);\n  writeTimeInstant(end, filter.end);\n}\n\n/**\n * @param {Node} node Node.\n * @param {import(\"./filter/LogicalNary.js\").default} filter Filter.\n * @param {Array<*>} objectStack Node stack.\n */\nfunction writeLogicalFilter(node, filter, objectStack) {\n  /** @type {import(\"../xml.js\").NodeStackItem} */\n  const item = {node: node};\n  const conditions = filter.conditions;\n  for (let i = 0, ii = conditions.length; i < ii; ++i) {\n    const condition = conditions[i];\n    pushSerializeAndPop(\n      item,\n      GETFEATURE_SERIALIZERS,\n      makeSimpleNodeFactory(condition.getTagName()),\n      [condition],\n      objectStack\n    );\n  }\n}\n\n/**\n * @param {Node} node Node.\n * @param {import(\"./filter/Not.js\").default} filter Filter.\n * @param {Array<*>} objectStack Node stack.\n */\nfunction writeNotFilter(node, filter, objectStack) {\n  /** @type {import(\"../xml.js\").NodeStackItem} */\n  const item = {node: node};\n  const condition = filter.condition;\n  pushSerializeAndPop(\n    item,\n    GETFEATURE_SERIALIZERS,\n    makeSimpleNodeFactory(condition.getTagName()),\n    [condition],\n    objectStack\n  );\n}\n\n/**\n * @param {Element} node Node.\n * @param {import(\"./filter/ComparisonBinary.js\").default} filter Filter.\n * @param {Array<*>} objectStack Node stack.\n */\nfunction writeComparisonFilter(node, filter, objectStack) {\n  if (filter.matchCase !== undefined) {\n    node.setAttribute('matchCase', filter.matchCase.toString());\n  }\n  writeOgcPropertyName(node, filter.propertyName);\n  writeOgcLiteral(node, '' + filter.expression);\n}\n\n/**\n * @param {Node} node Node.\n * @param {import(\"./filter/IsNull.js\").default} filter Filter.\n * @param {Array<*>} objectStack Node stack.\n */\nfunction writeIsNullFilter(node, filter, objectStack) {\n  writeOgcPropertyName(node, filter.propertyName);\n}\n\n/**\n * @param {Node} node Node.\n * @param {import(\"./filter/IsBetween.js\").default} filter Filter.\n * @param {Array<*>} objectStack Node stack.\n */\nfunction writeIsBetweenFilter(node, filter, objectStack) {\n  writeOgcPropertyName(node, filter.propertyName);\n\n  const lowerBoundary = createElementNS(OGCNS, 'LowerBoundary');\n  node.appendChild(lowerBoundary);\n  writeOgcLiteral(lowerBoundary, '' + filter.lowerBoundary);\n\n  const upperBoundary = createElementNS(OGCNS, 'UpperBoundary');\n  node.appendChild(upperBoundary);\n  writeOgcLiteral(upperBoundary, '' + filter.upperBoundary);\n}\n\n/**\n * @param {Element} node Node.\n * @param {import(\"./filter/IsLike.js\").default} filter Filter.\n * @param {Array<*>} objectStack Node stack.\n */\nfunction writeIsLikeFilter(node, filter, objectStack) {\n  node.setAttribute('wildCard', filter.wildCard);\n  node.setAttribute('singleChar', filter.singleChar);\n  node.setAttribute('escapeChar', filter.escapeChar);\n  if (filter.matchCase !== undefined) {\n    node.setAttribute('matchCase', filter.matchCase.toString());\n  }\n  writeOgcPropertyName(node, filter.propertyName);\n  writeOgcLiteral(node, '' + filter.pattern);\n}\n\n/**\n * @param {string} tagName Tag name.\n * @param {Node} node Node.\n * @param {string} value Value.\n */\nfunction writeOgcExpression(tagName, node, value) {\n  const property = createElementNS(OGCNS, tagName);\n  writeStringTextNode(property, value);\n  node.appendChild(property);\n}\n\n/**\n * @param {Node} node Node.\n * @param {string} value PropertyName value.\n */\nfunction writeOgcPropertyName(node, value) {\n  writeOgcExpression('PropertyName', node, value);\n}\n\n/**\n * @param {Node} node Node.\n * @param {string} value PropertyName value.\n */\nfunction writeOgcLiteral(node, value) {\n  writeOgcExpression('Literal', node, value);\n}\n\n/**\n * @param {Node} node Node.\n * @param {string} time PropertyName value.\n */\nfunction writeTimeInstant(node, time) {\n  const timeInstant = createElementNS(GMLNS, 'TimeInstant');\n  node.appendChild(timeInstant);\n\n  const timePosition = createElementNS(GMLNS, 'timePosition');\n  timeInstant.appendChild(timePosition);\n  writeStringTextNode(timePosition, time);\n}\n\n/**\n * Encode filter as WFS `Filter` and return the Node.\n *\n * @param {import(\"./filter/Filter.js\").default} filter Filter.\n * @return {Node} Result.\n * @api\n */\nexport function writeFilter(filter) {\n  const child = createElementNS(OGCNS, 'Filter');\n  writeFilterCondition(child, filter, []);\n  return child;\n}\n\n/**\n * @param {Node} node Node.\n * @param {Array<string>} featureTypes Feature types.\n * @param {Array<*>} objectStack Node stack.\n */\nfunction writeGetFeature(node, featureTypes, objectStack) {\n  const context = /** @type {Object} */ (objectStack[objectStack.length - 1]);\n  const item = /** @type {import(\"../xml.js\").NodeStackItem} */ (assign(\n    {},\n    context\n  ));\n  item.node = node;\n  pushSerializeAndPop(\n    item,\n    GETFEATURE_SERIALIZERS,\n    makeSimpleNodeFactory('Query'),\n    featureTypes,\n    objectStack\n  );\n}\n\nexport default WFS;\n","import Map from '../src/ol/Map.js';\nimport VectorSource from '../src/ol/source/Vector.js';\nimport View from '../src/ol/View.js';\nimport XYZ from '../src/ol/source/XYZ.js';\nimport {GeoJSON, WFS} from '../src/ol/format.js';\nimport {Stroke, Style} from '../src/ol/style.js';\nimport {Tile as TileLayer, Vector as VectorLayer} from '../src/ol/layer.js';\nimport {\n  and as andFilter,\n  equalTo as equalToFilter,\n  like as likeFilter,\n} from '../src/ol/format/filter.js';\n\nconst vectorSource = new VectorSource();\nconst vector = new VectorLayer({\n  source: vectorSource,\n  style: new Style({\n    stroke: new Stroke({\n      color: 'rgba(0, 0, 255, 1.0)',\n      width: 2,\n    }),\n  }),\n});\n\nconst key = 'get_your_own_D6rA4zTHduk6KOKTXzGB';\nconst attributions =\n  '<a href=\"https://www.maptiler.com/copyright/\" target=\"_blank\">&copy; MapTiler</a> ' +\n  '<a href=\"https://www.openstreetmap.org/copyright\" target=\"_blank\">&copy; OpenStreetMap contributors</a>';\n\nconst raster = new TileLayer({\n  source: new XYZ({\n    attributions: attributions,\n    url: 'https://api.maptiler.com/tiles/satellite/{z}/{x}/{y}.jpg?key=' + key,\n    maxZoom: 20,\n  }),\n});\n\nconst map = new Map({\n  layers: [raster, vector],\n  target: document.getElementById('map'),\n  view: new View({\n    center: [-8908887.277395891, 5381918.072437216],\n    maxZoom: 19,\n    zoom: 12,\n  }),\n});\n\n// generate a GetFeature request\nconst featureRequest = new WFS().writeGetFeature({\n  srsName: 'EPSG:3857',\n  featureNS: 'http://openstreemap.org',\n  featurePrefix: 'osm',\n  featureTypes: ['water_areas'],\n  outputFormat: 'application/json',\n  filter: andFilter(\n    likeFilter('name', 'Mississippi*'),\n    equalToFilter('waterway', 'riverbank')\n  ),\n});\n\n// then post the request and add the received features to a layer\nfetch('https://ahocevar.com/geoserver/wfs', {\n  method: 'POST',\n  body: new XMLSerializer().serializeToString(featureRequest),\n})\n  .then(function (response) {\n    return response.json();\n  })\n  .then(function (json) {\n    const features = new GeoJSON().readFeatures(json);\n    vectorSource.addFeatures(features);\n    map.getView().fit(vectorSource.getExtent());\n  });\n"],"sourceRoot":""}